# Born2beroot 동료 평가 대비 가이드

> **이 문서의 사용법:** 이 문서는 한 번 읽는 것이 아니라 한 번 **겪는** 것입니다.
> `생각해보기` 구간에서는 반드시 멈추고, 머릿속으로 답을 만들어 본 뒤에 다음으로 넘어가세요.
> 답을 먼저 보면 이 문서의 가치는 0이 됩니다.
>
> [Born2beroot 42 가이드 (한국어)](README_KR.md)와 함께 사용하세요.

---

## 목차

**1부: 개념을 내 것으로 만들기**
1. [가상 머신 — 컴퓨터 안의 컴퓨터](#1-가상-머신--컴퓨터-안의-컴퓨터)
2. [운영체제 선택 — 왜 Debian인가](#2-운영체제-선택--왜-debian인가)
3. [apt vs aptitude — 택배 기사의 차이](#3-apt-vs-aptitude--택배-기사의-차이)
4. [AppArmor — 보디가드는 어떻게 일하는가](#4-apparmor--보디가드는-어떻게-일하는가)
5. [파티션과 LVM — 왜 방을 나누는가](#5-파티션과-lvm--왜-방을-나누는가)
6. [sudo — 열쇠가 아니라 허가증이다](#6-sudo--열쇠가-아니라-허가증이다)
7. [UFW — 문은 왜 잠그는가](#7-ufw--문은-왜-잠그는가)
8. [SSH — 비밀 통로로 말하기](#8-ssh--비밀-통로로-말하기)
9. [cron — 알람시계의 원리](#9-cron--알람시계의-원리)
10. [비밀번호 정책 — 귀찮음의 이유](#10-비밀번호-정책--귀찮음의-이유)

**2부: 손으로 증명하기**
11. [평가 전 점검](#11-평가-전-점검)
12. [서명 검증](#12-서명-검증)
13. [서비스 상태 확인](#13-서비스-상태-확인)
14. [사용자와 그룹](#14-사용자와-그룹)
15. [비밀번호 정책 시연](#15-비밀번호-정책-시연)
16. [호스트명 변경](#16-호스트명-변경)
17. [파티션 확인](#17-파티션-확인)
18. [sudo 검증](#18-sudo-검증)
19. [UFW 조작](#19-ufw-조작)
20. [SSH 검증](#20-ssh-검증)
21. [모니터링 스크립트](#21-모니터링-스크립트)
22. [cron 주기 변경](#22-cron-주기-변경)

---

# 1부: 개념을 내 것으로 만들기

---

## 1. 가상 머신 — 컴퓨터 안의 컴퓨터

### 출발점

지금 당신 앞에 노트북이 있습니다. macOS든 Windows든 리눅스든, 하나의 운영체제가 돌아가고 있죠.

> **생각해보기:** 지금 이 노트북 위에서 동시에 Debian 리눅스도 실행하고 싶다면, 어떻게 해야 할까요? 하드디스크를 나눠서 듀얼부팅? USB로 라이브 부팅? 다른 방법은?

당신이 생각한 방법 중에 "소프트웨어로 가짜 컴퓨터를 하나 만들면 되지 않을까?"라는 아이디어가 있었다면, 그것이 바로 가상 머신입니다.

### 핵심 아이디어

가상 머신은 **소프트웨어가 하드웨어인 척하는 것**입니다.

실제 CPU가 하나인데, 소프트웨어가 "여기 CPU 두 개 있어요"라고 거짓말합니다. 실제 RAM이 16GB인데, "당신에게 4GB 드릴게요"라고 나눠줍니다. 게스트 OS는 이 거짓말을 믿고, 진짜 컴퓨터 위에서 돌아가는 것처럼 행동합니다.

이 거짓말을 관리하는 소프트웨어가 **하이퍼바이저(Hypervisor)** 입니다.

### Type 1 vs Type 2

> **생각해보기:** 하이퍼바이저가 거짓말쟁이라면, 이 거짓말쟁이가 **어디에 서 있는지**가 중요합니다. 두 가지 위치가 가능한데, 어디일까요?

**Type 1 — 하드웨어 바로 위에 서 있는 경우:**
운영체제 없이, 하이퍼바이저가 하드웨어를 직접 제어합니다. 중간 다리가 없으니 빠릅니다. 데이터센터의 서버가 이렇게 돌아갑니다. (VMware ESXi, Proxmox)

**Type 2 — 운영체제 위에 앱으로 서 있는 경우:**
macOS나 Windows 위에서 VirtualBox라는 앱을 실행합니다. 앱이 내부적으로 가짜 하드웨어를 만들어 줍니다. 우리가 쓰는 VirtualBox가 이것입니다.

> **생각해보기:** Type 1이 더 빠른데 왜 우리는 Type 2를 쓸까요? 그리고 Type 2의 근본적인 한계는 뭘까요?

Type 2는 호스트 OS 위에서 또 하나의 앱으로 돌아가므로, 호스트 OS가 먼저 자원을 먹고 남는 것을 나눠 받습니다. 하지만 개인 PC에서 **기존 작업 환경을 유지하면서** 가상 머신을 쓸 수 있다는 편의성이 있습니다. 서버실에서라면 당연히 Type 1이지만, 42의 클러스터 Mac에서라면 Type 2가 현실적 선택입니다.

### 가상 머신을 쓰는 이유

> **생각해보기:** 듀얼부팅으로도 두 OS를 쓸 수 있는데, 왜 굳이 가상 머신을 쓸까요? 듀얼부팅으로는 절대 할 수 없지만 가상 머신으로는 할 수 있는 것이 무엇일까요?

핵심은 **동시 실행**과 **격리**입니다.

- 듀얼부팅은 한 번에 하나의 OS만 씁니다. 가상 머신은 여러 OS를 **동시에** 돌립니다.
- 가상 머신 안에서 무슨 짓을 해도 호스트에는 영향이 없습니다. `rm -rf /`를 해도 호스트는 멀쩡합니다.
- 스냅샷을 찍어두면 언제든 그 시점으로 돌아갈 수 있습니다. 마치 게임의 세이브 포인트처럼.

### 자기 점검

아래 질문에 입으로 소리 내어 답해보세요. 막히는 부분이 있다면, 위로 돌아가서 다시 읽으세요.

1. "가상 머신이 뭐야?"라고 물으면, 한 문장으로 뭐라고 답하겠는가?
2. VirtualBox는 Type 몇 하이퍼바이저이며, 그것이 의미하는 바는?
3. 가상 머신이 컨테이너(Docker)와 다른 점은 무엇인가? (힌트: 커널을 공유하는가?)

---

## 2. 운영체제 선택 — 왜 Debian인가

### 선택지

Born2beroot은 **Debian** 또는 **Rocky Linux** 중 하나를 선택하게 합니다.

> **생각해보기:** 이 두 배포판의 이름을 처음 들어봤다고 칩시다. "Debian"과 "Rocky Linux"가 각각 리눅스 세계에서 어떤 위치인지 전혀 모른다고 가정하고, 다음 사실만으로 추론해보세요:
>
> - Ubuntu는 Debian을 기반으로 만들어졌다
> - Rocky Linux는 기업이 돈을 내고 쓰던 Red Hat Enterprise Linux(RHEL)의 소스코드로 만들어졌다
>
> 이것만으로 두 배포판의 성격이 어떻게 다를지 추측할 수 있나요?

### 두 세계

리눅스 배포판은 크게 두 갈래입니다:

**Debian 계열:** Debian → Ubuntu → Linux Mint → ...
- 패키지 형식: `.deb`
- 패키지 관리: `apt` / `aptitude`
- 보안 모듈: **AppArmor**
- 방화벽: **UFW**
- 성격: 커뮤니티 중심, 안정성 우선, 범용적

**RHEL 계열:** RHEL → CentOS(사망) → Rocky Linux / AlmaLinux
- 패키지 형식: `.rpm`
- 패키지 관리: `dnf` (구 `yum`)
- 보안 모듈: **SELinux**
- 방화벽: **firewalld**
- 성격: 기업 환경, 장기 지원, 보수적 업데이트

> **생각해보기:** 프로젝트 서브젝트에 "시스템 관리가 처음이라면 Debian을 추천한다"고 적혀 있습니다. 왜 그럴까요? 위의 두 계열을 비교해보면 힌트가 있습니다.

Debian이 초보자에게 유리한 이유는 **설치 과정이 단순**하고, **커뮤니티 문서가 방대**하며, AppArmor와 UFW가 SELinux와 firewalld보다 **설정 진입장벽이 낮기** 때문입니다. 서버로서의 안정성도 수십 년에 걸쳐 검증되었습니다.

### 평가에서 이렇게 답하세요

"왜 Debian을 선택했나요?"라는 질문에 비교표를 외워서 읊는 것이 아닙니다.

**자기 말로** 이렇게 답할 수 있어야 합니다:
> "시스템 관리가 처음이라 진입장벽이 낮은 쪽을 택했습니다. Debian은 APT 생태계와 AppArmor, UFW 등 비교적 직관적인 도구를 쓰고, 커뮤니티 자료도 풍부합니다. 또한 Ubuntu의 기반이기 때문에, 여기서 배운 것이 나중에도 쓸모가 있다고 판단했습니다."

핵심은 **자기가 왜 그 선택을 했는지 논리적으로 설명**할 수 있느냐입니다.

---

## 3. apt vs aptitude — 택배 기사의 차이

### 비유로 시작

리눅스에서 소프트웨어를 설치한다는 것은, **패키지**라는 택배 상자를 받아서 여는 것과 같습니다. 그런데 택배 상자에는 종종 이런 쪽지가 붙어 있습니다: "이 상자를 열려면 먼저 A 상자와 B 상자가 필요합니다." 이것이 **의존성(dependency)** 입니다.

**apt**와 **aptitude**는 둘 다 이 택배를 배달해주는 기사입니다. 하지만 일하는 방식이 다릅니다.

### apt — 직선적인 기사

`apt`는 단순합니다. "X 설치해줘" 하면 X와 그 의존성을 다운로드하고 설치합니다. 문제가 생기면?

```
다음 패키지에 충족할 수 없는 의존성이 있습니다:
  패키지A: 의존: 패키지B (>= 2.0) 하지만 1.8 버전이 설치됨
E: 오류, 설치할 수 없습니다
```

apt는 **"안 돼요, 못 해요"** 하고 멈춥니다. 해결은 당신 몫입니다.

### aptitude — 해결사 기사

`aptitude`는 같은 상황에서 다르게 행동합니다:

```
다음 동작이 의존성 문제를 해결합니다:
  해결책 1: 패키지B를 2.0으로 업그레이드
  해결책 2: 패키지A를 설치하지 않음
  해결책 3: 패키지C를 제거하고 패키지B 2.0을 설치

이 해결책을 수락하시겠습니까? [Y/n/q/?]
```

aptitude는 **여러 해결 방안을 제시**합니다. 또한 ncurses 기반의 텍스트 UI도 제공하고, 사용하지 않게 된 패키지를 자동으로 추적하여 제거를 제안합니다.

> **생각해보기:** 그렇다면 aptitude가 무조건 더 좋은 것 아닌가요? apt를 쓰는 이유가 있을까요?

단순함에는 가치가 있습니다. 스크립트에서 자동화할 때, 인간의 판단이 필요한 aptitude보다 예측 가능한 apt가 더 적합합니다. 또한 apt는 Debian에 기본 설치되어 있지만 aptitude는 따로 설치해야 합니다. 대부분의 일상적 패키지 관리에서는 apt로 충분합니다.

### 자기 점검

다음 상황을 상상해보세요:

> 패키지 X를 설치하려는데, X는 Y 버전 2.0 이상을 필요로 합니다. 그런데 이미 설치된 패키지 Z가 Y 버전 1.x를 필요로 합니다. Y를 업그레이드하면 Z가 깨집니다.

- apt는 이 상황에서 어떻게 반응하나요?
- aptitude는 어떻게 반응하나요?
- 당신이라면 어떤 도구를 쓸 건가요?

---

## 4. AppArmor — 보디가드는 어떻게 일하는가

### 문제 상황

> **생각해보기:** 당신이 서버 관리자입니다. 웹 서버 프로그램(예: nginx)이 돌아가고 있습니다. 이 프로그램에 보안 취약점이 발견되어, 공격자가 nginx를 통해 서버에 침투했습니다. 공격자는 이제 nginx의 권한으로 무엇이든 할 수 있습니다.
>
> 질문: nginx가 정상적으로 하는 일은 무엇이고, 절대 해서는 안 되는 일은 무엇인가요?

nginx는 `/var/www/html`에서 웹 파일을 읽고, 포트 80/443에서 요청을 받아야 합니다.
nginx가 `/etc/shadow`(비밀번호 해시 파일)를 읽거나, `/home` 디렉터리를 뒤지거나, 새로운 네트워크 연결을 임의로 만드는 것은 **정상이 아닙니다.**

바로 여기서 **AppArmor**가 등장합니다.

### AppArmor의 원리

AppArmor는 각 프로그램에 **프로파일(profile)** 이라는 허가증을 붙입니다. 프로파일에는 "이 프로그램은 이 파일을 읽을 수 있고, 저 파일은 안 돼"라고 적혀 있습니다.

```
# nginx의 AppArmor 프로파일 (개념적 예시)
/usr/sbin/nginx {
    /var/www/html/** r,          # 웹 파일 읽기 허용
    /var/log/nginx/** w,         # 로그 쓰기 허용
    /etc/nginx/** r,             # 설정 파일 읽기 허용
    network inet tcp,            # TCP 네트워크 허용

    # 그 외 모든 것은 거부됨
}
```

공격자가 nginx를 장악해도, AppArmor가 "아, nginx는 `/etc/shadow` 접근 권한이 없는데요?"하고 차단합니다. 프로그램이 뚫려도 **피해 범위가 프로파일 안으로 제한**됩니다.

### 경로 기반 vs 레이블 기반

AppArmor는 **경로(path)** 를 봅니다: "이 파일은 `/var/www/html`에 있으니까 허용."

반면 SELinux(Rocky Linux에서 사용)는 **레이블(label)** 을 봅니다: "이 파일에 `httpd_content_t`라는 꼬리표가 붙어 있으니까 허용."

> **생각해보기:** 파일을 `/var/www/html`에서 `/tmp`로 이동하면, AppArmor와 SELinux는 각각 어떻게 반응할까요?

AppArmor: 경로가 바뀌었으므로 접근이 **차단**됩니다. 새 경로에 대한 규칙이 없기 때문입니다.

SELinux: 파일에 붙은 레이블이 함께 이동하면 여전히 **허용**됩니다. 레이블은 파일에 붙어 다니기 때문입니다. (단, `mv` 시 레이블이 유지되고, `cp` 시 대상 디렉터리의 레이블을 따릅니다.)

이 차이가 왜 중요한가요? 경로 기반은 직관적이고 설정이 쉽습니다. 레이블 기반은 파일이 어디로 이동하든 보안 정책이 따라다니므로 더 견고합니다. 이것이 SELinux가 더 복잡하지만 더 강력하다고 평가받는 이유입니다.

### enforce vs complain

```bash
sudo aa-status
```

이 명령어를 치면 **enforce 모드**와 **complain 모드**의 프로파일이 보입니다.

- **enforce**: 규칙 위반을 **실제로 차단**합니다. 실전 모드.
- **complain**: 위반을 **로그에 기록만** 합니다. 연습 모드.

> **생각해보기:** complain 모드는 왜 존재할까요? enforce만 있으면 안 될까요?

새 프로파일을 만들 때, 처음부터 enforce로 걸면 정상 동작에 필요한 경로를 빠뜨려서 프로그램이 동작하지 않을 수 있습니다. 먼저 complain으로 걸어서 "이 프로그램이 실제로 어디에 접근하는지" 로그를 수집한 뒤, 그것을 바탕으로 프로파일을 완성하고 enforce로 전환하는 것이 일반적인 워크플로우입니다.

---

## 5. 파티션과 LVM — 왜 방을 나누는가

### 방 하나짜리 집

> **생각해보기:** 원룸(방 하나)에 삽니다. 침대, 책상, 주방, 옷장이 모두 같은 공간에 있습니다. 이것의 문제는 무엇일까요?

요리하다 기름이 튀면 침대에 묻습니다. 친구가 오면 지저분한 주방도 다 보입니다. 한 영역의 문제가 다른 영역에 직접적으로 영향을 줍니다.

이것이 **파티션 하나짜리 디스크**입니다. `/`(루트) 하나에 모든 것이 들어 있으면:

- 사용자가 `/home`에 대용량 파일을 다운받아서 디스크가 꽉 차면 → 시스템 로그(`/var/log`)도 더 이상 쓸 수 없고 → OS 자체가 멈출 수 있습니다.
- 하나의 파일 시스템이 손상되면 → 전체 시스템이 망가집니다.

### 방을 나누면

파티션을 나누면 각 영역이 **독립**됩니다:

| 파티션 | 마운트 포인트 | 역할 | 왜 분리하는가 |
|--------|-------------|------|-------------|
| boot | `/boot` | 부트로더, 커널 | 부팅에 필수적인 파일이 다른 영향을 받지 않도록 |
| root | `/` | 운영체제 핵심 | OS의 핵심 파일 보호 |
| home | `/home` | 사용자 데이터 | 사용자가 디스크를 채워도 OS에 영향 없음 |
| var | `/var` | 로그, 캐시 | 로그 폭주가 OS를 죽이지 않도록 |
| tmp | `/tmp` | 임시 파일 | 임시 파일이 넘쳐도 다른 영역은 안전 |
| swap | [swap] | 가상 메모리 | RAM이 부족할 때 디스크를 메모리처럼 사용 |

> **생각해보기:** 만약 `/var/log`를 분리하지 않았는데, 공격자가 서버에 침투해서 의도적으로 로그를 무한히 생성하면 어떤 일이 벌어질까요?

`/var`가 루트와 같은 파티션이면, 로그가 디스크를 가득 채워 OS 전체가 마비됩니다. 분리되어 있다면, `/var` 파티션만 가득 차고 나머지는 정상 동작합니다. 이것이 보안과 안정성 관점에서 파티션을 나누는 근본적 이유입니다.

### LVM — 리모델링이 가능한 벽

전통적인 파티션은 **콘크리트 벽**입니다. 한번 정하면 바꾸기 매우 어렵습니다.

LVM(Logical Volume Manager)은 **이동식 칸막이**입니다.

```
물리 디스크(PV) → 하나의 큰 공간으로 합침(VG) → 원하는 대로 나눔(LV)

Physical Volume    Volume Group          Logical Volume
실제 디스크/파티션 → 저장소 풀(수영장)   → 가상 파티션(레인)
```

> **생각해보기:** 아까 방 비유를 이어갑시다. 처음에 서재에 2평을 줬는데, 책이 늘어서 4평이 필요합니다. 콘크리트 벽이면 어떻게 해야 할까요? 이동식 칸막이면?

LVM이 있으면 시스템이 돌아가는 **동안에도** 볼륨 크기를 변경할 수 있습니다. 이것이 서버 환경에서 LVM이 사실상 표준인 이유입니다.

### 암호화

Born2beroot에서는 **암호화된 LVM**을 사용합니다.

> **생각해보기:** 파티션을 암호화한다는 것은 구체적으로 무엇을 의미할까요? 누구로부터 무엇을 보호하는 건가요?

서버의 물리적 하드디스크를 누군가 빼서 다른 컴퓨터에 연결하면, 암호화가 없다면 모든 데이터를 그냥 읽을 수 있습니다. LUKS 암호화가 걸려 있으면, 올바른 패스프레이즈(passphrase) 없이는 디스크의 내용이 무작위 바이트로 보입니다. 이것은 **물리적 접근에 대한 방어**입니다.

부팅할 때마다 암호화 비밀번호를 입력해야 하는 이유가 바로 이것입니다.

### 자기 점검

VM에서 `lsblk`를 실행해보세요. 출력의 각 줄이 무엇을 의미하는지 옆 사람에게 설명할 수 있나요?

- `sda`는 뭔가요?
- `sda1`, `sda2`는?
- `crypt`가 붙은 것은?
- `lvm`이 붙은 것은?
- 왜 어떤 것은 `part`이고 어떤 것은 `lvm`인가요?

---

## 6. sudo — 열쇠가 아니라 허가증이다

### root라는 존재

리눅스에서 `root`는 **신**입니다. 모든 파일을 읽고, 모든 프로세스를 죽이고, 시스템을 포맷할 수도 있습니다. 제한이 없습니다.

> **생각해보기:** 그렇다면 왜 그냥 root로 로그인해서 작업하면 안 될까요? 편하잖아요?

### 아파트 관리인을 생각해보세요

건물의 마스터키는 모든 문을 열 수 있습니다. 관리인이 마스터키를 들고 항상 다닌다면:
- 실수로 엉뚱한 방문을 열 수 있습니다
- 마스터키를 잃어버리면 건물 전체가 위험합니다
- 누가 언제 어떤 방에 들어갔는지 추적할 수 없습니다

sudo는 이런 방식입니다:
- 관리인은 평소에 일반 열쇠만 들고 다닙니다 (일반 사용자)
- 특정 방에 들어가야 할 때, **관리 사무소에 가서 신청서를 쓰고** 허가를 받습니다 (`sudo` 명령)
- 신청서에는 누가, 언제, 어떤 방에 들어갔는지 기록됩니다 (로그)
- 비밀번호를 3번 틀리면 더 이상 시도할 수 없습니다 (`passwd_tries=3`)

이것이 **최소 권한 원칙(Principle of Least Privilege)** 입니다.

### Born2beroot의 sudo 설정을 하나씩 뜯어보기

각 설정이 **왜** 필요한지 생각해보세요:

**`Defaults requiretty`**

> **생각해보기:** TTY는 터미널입니다. sudo를 터미널에서만 쓸 수 있게 제한하는 것이 왜 보안에 도움이 될까요?

자동화된 스크립트나 원격 공격이 sudo를 호출하는 것을 막습니다. 인간이 직접 터미널 앞에 앉아서 실행하도록 강제하는 것입니다.

**`Defaults logfile="/var/log/sudo/sudo.log"` + `log_input` + `log_output`**

모든 sudo 사용을 기록합니다. 보안 사고가 발생했을 때, "누가 언제 무엇을 했는지" 추적할 수 있어야 합니다. 입력과 출력까지 기록하는 것은 "어떤 명령을 쳤고, 그 결과가 무엇이었는지"까지 남기기 위함입니다.

**`Defaults secure_path="..."`**

> **생각해보기:** 공격자가 `/tmp/ls`라는 악성 프로그램을 만들어 두고, PATH를 조작해서 `sudo ls`를 칠 때 `/tmp/ls`가 실행되게 하면 어떻게 될까요?

`secure_path`는 sudo가 사용하는 PATH를 **고정**시킵니다. 사용자가 PATH를 아무리 조작해도, sudo는 항상 지정된 경로에서만 프로그램을 찾습니다. 이것은 **PATH 하이재킹 공격**을 방지합니다.

---

## 7. UFW — 문은 왜 잠그는가

### 포트라는 개념

> **생각해보기:** 서버의 IP 주소가 하나인데, 웹 서버도 돌리고 SSH도 돌리고 이메일 서버도 돌립니다. 클라이언트가 접속할 때, 같은 IP 주소로 오는 요청을 어떻게 구분할까요?

**포트(port)** 입니다. IP 주소가 건물 주소라면, 포트 번호는 **호실 번호**입니다.

- 80호: 웹 서버 (HTTP)
- 443호: 보안 웹 서버 (HTTPS)
- 22호: SSH
- 4242호: Born2beroot에서 SSH가 이사한 곳

총 65535개의 방이 있습니다.

### 방화벽이 필요한 이유

> **생각해보기:** 65535개의 방이 있는 건물에서 실제로 쓰는 방은 1-2개뿐입니다. 나머지 65533개의 문은 어떻게 해야 할까요?

당연히 잠가야 합니다. 열린 포트는 **공격의 입구**입니다.

UFW는 이 문들의 잠금장치입니다. Born2beroot에서의 설정:

```
ufw default deny incoming     # 모든 문을 잠금
ufw default allow outgoing    # 나가는 것은 허용
ufw allow 4242                # 4242호만 열어둠
```

> **생각해보기:** outgoing은 왜 전부 허용할까요? 나가는 것도 막으면 더 안전하지 않나요?

서버가 외부와 전혀 통신하지 못하면 패키지 업데이트(`apt update`)도, DNS 조회도, 시간 동기화도 할 수 없습니다. 서버가 **기능하려면** 나가는 트래픽은 열어두어야 합니다. 물론 극도로 보안이 중요한 환경에서는 아웃바운드도 화이트리스트 방식으로 관리합니다.

### UFW vs firewalld

Born2beroot에서 Debian을 선택하면 UFW, Rocky를 선택하면 firewalld를 씁니다.

둘 다 내부적으로는 **iptables**(또는 nftables)라는 리눅스 커널의 패킷 필터링 시스템을 사용합니다. UFW와 firewalld는 이 복잡한 시스템을 인간이 쉽게 쓸 수 있도록 감싼 **프론트엔드**일 뿐입니다.

차이점: UFW는 **규칙 목록** 방식 (이 포트 허용, 저 포트 차단), firewalld는 **zone** 방식 (이 네트워크 인터페이스는 trust zone, 저것은 public zone)으로 관리합니다. UFW가 단순하고, firewalld가 더 유연하지만 복잡합니다.

---

## 8. SSH — 비밀 통로로 말하기

### 왜 필요한가

서버가 데이터센터에 있습니다. 관리하려면 직접 가야 할까요?

당연히 아닙니다. **원격으로 접속**합니다. 그런데 인터넷은 공개 네트워크입니다. 당신이 치는 명령어, 비밀번호가 네트워크를 지나갑니다.

> **생각해보기:** 카페에서 노트북으로 서버에 접속합니다. 같은 와이파이를 쓰는 옆자리 사람이 패킷을 들여다볼 수 있다면(패킷 스니핑), 무엇이 위험할까요?

비밀번호가 평문으로 날아가면 그대로 탈취됩니다. SSH는 모든 통신을 **암호화**합니다.

### SSH 동작의 핵심

자물쇠와 열쇠로 비유합니다:

1. 서버가 **자물쇠(공개키)** 를 클라이언트에게 보냅니다
2. 클라이언트가 **대칭 세션 키**를 만들어서, 이 자물쇠로 잠궈 보냅니다
3. 서버는 자기만 가진 **열쇠(개인키)** 로 열어서 세션 키를 획득합니다
4. 이후 모든 통신은 이 **세션 키**로 암호화됩니다

중간에서 누가 패킷을 가로채도, 세션 키 없이는 해독할 수 없습니다.

### Born2beroot의 SSH 설정

**포트 4242를 쓰는 이유:**

> **생각해보기:** 포트 번호를 바꾸는 것이 진정한 보안인가요? 공격자가 포트 스캔을 하면 4242에서 SSH가 돌아가는 것을 금방 찾지 않을까요?

맞습니다. 포트 변경은 **보안이 아니라 소음 필터링**입니다. 인터넷에는 포트 22를 무차별 공격하는 봇이 수없이 많습니다. 4242로 바꾸면 이런 **자동화된 공격을 피할** 수 있지만, 의도적인 공격자는 포트 스캔으로 금방 찾습니다. 그래서 포트 변경은 보안 **계층 중 하나**이지, 그것만으로 안전하다고 할 수 없습니다.

**root SSH 접속 차단:**

root로 직접 SSH 접속이 가능하면, 공격자는 사용자명을 이미 알고 있는 셈입니다 (`root`). 비밀번호만 뚫으면 됩니다. 차단하면 공격자는 **유효한 사용자명**부터 알아내야 하므로 난이도가 올라갑니다.

---

## 9. cron — 알람시계의 원리

### 개념

> **생각해보기:** 10분마다 서버 상태를 화면에 출력하는 스크립트가 있습니다. 이걸 어떻게 구현하겠습니까? `while true; do ... ; sleep 600; done` 같은 무한 루프? 그 방법의 문제점은?

무한 루프 방식의 문제:
- 프로세스가 죽으면 자동으로 재시작하지 않음
- 정확한 시간 간격을 보장하기 어려움 (스크립트 실행 시간이 누적됨)
- 시스템 시작 시 자동으로 실행하려면 추가 설정 필요

**cron**은 이 문제를 해결하는 시스템 데몬입니다. 시스템이 시작될 때 자동으로 실행되고, 정해진 시각에 정확히 작업을 실행합니다.

### crontab 문법 — 직접 읽어보기

```
*/10 * * * * bash /etc/cron.d/monitoring.sh | wall
```

이 한 줄을 왼쪽부터 읽어봅시다:

```
┌─ */10 : 분 필드. */10은 "10으로 나누어 떨어지는 매 분" = 0, 10, 20, 30, 40, 50분
│  ┌─ * : 시 필드. *은 "매 시"
│  │  ┌─ * : 일 필드. "매일"
│  │  │  ┌─ * : 월 필드. "매월"
│  │  │  │  ┌─ * : 요일 필드. "매 요일"
│  │  │  │  │
*/10 * * * *  bash /etc/cron.d/monitoring.sh | wall
```

> **생각해보기:** 다음 crontab 표현식들이 무엇을 의미하는지 맞춰보세요:
> 1. `0 3 * * 1`
> 2. `30 */2 * * *`
> 3. `0 0 1 * *`
>
> 답을 생각한 뒤에 아래로 내려가세요.

1. 매주 **월요일 오전 3시 0분** (요일: 1 = 월요일)
2. **2시간마다 30분에** (2시 30분, 4시 30분, 6시 30분...)
3. **매월 1일 자정**

### 스크립트를 수정하지 않고 중단하기

> **생각해보기:** 평가자가 "모니터링을 중단해라, 하지만 스크립트 파일을 건드리지 마라"라고 합니다. 어떻게 하겠습니까?

방법은 여러 가지입니다. 핵심은 **실행의 주체를 공격**하는 것입니다:

1. **crontab에서 해당 줄을 삭제/주석 처리:** `sudo crontab -u root -e` → 줄 앞에 `#`을 붙이거나 삭제
2. **cron 서비스 자체를 중지:** `sudo systemctl stop cron`

스크립트 자체는 그대로 있지만, 그것을 실행시키는 **예약**을 없애거나 **예약 시스템**을 멈추는 것입니다.

---

## 10. 비밀번호 정책 — 귀찮음의 이유

### 공격자의 관점에서 생각하기

> **생각해보기:** 당신이 공격자라고 칩시다. 서버의 SSH 포트를 찾았고, 사용자명도 알아냈습니다. 비밀번호만 뚫으면 됩니다. 어떤 비밀번호를 먼저 시도하겠습니까?

1. `password`, `123456`, `admin` 같은 흔한 비밀번호 (**사전 공격**)
2. `a`, `aa`, `aaa`, ... `aaaa`, ... 모든 조합 시도 (**브루트포스**)
3. 사용자 이름과 비슷한 것: `jsmith`, `jsmith42`, `Jsmith!` (**추측 공격**)

Born2beroot의 비밀번호 정책은 **이 모든 공격 벡터를 하나씩 막는 것**입니다:

| 공격 유형 | 방어하는 규칙 | 왜 효과적인가 |
|-----------|-------------|-------------|
| 브루트포스 | `minlen=10` | 10자 = 영문+숫자만 해도 조합 수가 약 3.7경(3.7 x 10^15)개. 초당 1만 번 시도해도 11,700년 |
| 브루트포스 | `ucredit=-1`, `lcredit=-1`, `dcredit=-1` | 문자 집합을 강제 확대하여 조합 수 기하급수적 증가 |
| 사전 공격 | `maxrepeat=3` | `aaaa`, `1111` 같은 패턴 차단 |
| 추측 공격 | `reject_username` | 사용자명 기반 추측 차단 |
| 재사용 | `difok=7` | 이전 비밀번호와 7자 이상 달라야 함. `Password1` → `Password2` 같은 꼼수 차단 |
| 장기 노출 | `PASS_MAX_DAYS 30` | 유출되어도 30일 후엔 무효 |
| 정책 우회 | `PASS_MIN_DAYS 2` | 비밀번호를 연속으로 바꿔서 다시 원래 비밀번호로 돌아오는 꼼수 차단 |

> **생각해보기:** `PASS_MIN_DAYS 2`가 없다면, `difok=7` 정책을 어떻게 우회할 수 있을까요?

비밀번호를 여러 번 연달아 바꾸면 됩니다: 원래 → A → B → C → D → ... → 원래. 매번 7자 이상 다르게 바꾸면 결국 원래 비밀번호로 돌아올 수 있습니다. `PASS_MIN_DAYS 2`는 이 연속 변경을 막아서 최소 2일 간격을 강제합니다.

### 이 정책의 대가

> **생각해보기:** 이렇게 엄격한 정책의 단점은 무엇일까요? 이 단점이 현실 세계에서 어떤 역효과를 만들까요?

사용자가 비밀번호를 기억하지 못해 **포스트잇에 적어서 모니터에 붙입니다.** 30일마다 바꿔야 하니 `Summer2024!` → `Autumn2024!` 같은 **패턴**이 생깁니다. 정책이 강할수록 인간은 그 정책을 **회피하는 쪽으로** 적응합니다.

이것이 최근 NIST(미국 국립표준기술연구소)가 "주기적 비밀번호 변경을 강제하지 말라"고 권고를 바꾼 이유입니다. 하지만 Born2beroot은 **전통적인 비밀번호 정책의 각 요소가 어떤 공격을 방어하는지** 이해하게 하려는 것이므로, 이 정책을 따릅니다.

---

# 2부: 손으로 증명하기

여기서부터는 실제 평가에서 시연하는 항목입니다.
**각 명령어를 실행하기 전에**, 어떤 결과가 나올지 예측해보세요. 예측이 맞았는지 확인하는 과정이 학습입니다.

---

## 11. 평가 전 점검

평가 시작 전 반드시:

- [ ] Git 저장소에 `signature.txt`와 `README.md`만 존재하는지
- [ ] VM에 **스냅샷이 없는 상태**인지 (v5.2 요구사항)
- [ ] `signature.txt`의 내용이 현재 `.vdi` 파일의 SHA-1 해시와 일치하는지
- [ ] 부팅 시 그래픽 환경 없이, 암호화 비밀번호를 요구하는지

---

## 12. 서명 검증

**호스트 터미널에서:**

```bash
cd ~/VirtualBox\ VMs/<VM이름>/
sha1sum <파일명>.vdi
```

> **예측하기:** 이 명령어는 무엇을 출력할까요? 왜 SHA-1인가요? MD5가 아니라?

출력된 해시값과 `signature.txt`가 **글자 하나까지 동일**해야 합니다.

---

## 13. 서비스 상태 확인

```bash
sudo ufw status
sudo systemctl status ssh
sudo aa-status
```

> **예측하기:** 각 명령어를 실행하기 전에, 정상이라면 어떤 출력이 나올지 머릿속으로 그려보세요.
> - UFW: `Status: active`와 포트 4242 규칙
> - SSH: `active (running)`, port 4242
> - AppArmor: 로드된 프로파일 목록, enforce 모드

---

## 14. 사용자와 그룹

### 기존 확인

```bash
getent group sudo
getent group user42
```

> **예측하기:** 출력에 본인 로그인이 보여야 합니다. `getent group`은 뭘 하는 건가요? `/etc/group` 파일을 직접 읽는 것과 뭐가 다른가요?

`getent`는 NSS(Name Service Switch)를 통해 조회하므로, 로컬 파일뿐 아니라 LDAP 등 외부 소스도 포함합니다. 로컬 환경에서는 결과가 같지만, 원리는 다릅니다.

### 새 사용자 생성

```bash
sudo adduser <evaluator_name>
```

> **관찰하기:** 비밀번호를 설정할 때 정책이 적용되나요? 너무 짧거나, 숫자가 없거나, 사용자명을 포함한 비밀번호를 시도해보세요. 무슨 메시지가 나오나요?

```bash
sudo groupadd evaluating
sudo usermod -aG evaluating <evaluator_name>
getent group evaluating
```

> **생각해보기:** `usermod -aG`에서 `-a`를 빼면 어떻게 되나요? (힌트: `-G`만 쓰면 **기존 보조 그룹을 모두 덮어씁니다**. 매우 위험합니다.)

---

## 15. 비밀번호 정책 시연

```bash
sudo chage -l <your_login>
```

> **예측하기:** Maximum, Minimum, Warning 값이 각각 얼마여야 하나요? 답을 말해보고 실행해서 확인하세요.

```bash
# 복잡도 정책 확인
cat /etc/pam.d/common-password | grep pam_pwquality
```

> **도전:** 평가자 앞에서 `minlen=10 difok=7 maxrepeat=3 dcredit=-1 ucredit=-1 lcredit=-1 reject_username enforce_for_root`의 각 옵션이 **어떤 공격을 방어하는지** 설명할 수 있나요? 10번 섹션을 다시 읽지 않고 할 수 있다면 이해한 것입니다.

---

## 16. 호스트명 변경

```bash
hostnamectl
```

> **예측하기:** Static hostname이 `<your_login>42`로 나와야 합니다.

```bash
sudo hostnamectl set-hostname <new_hostname>
sudo nano /etc/hosts    # 127.0.1.1 줄의 호스트명도 변경
sudo reboot
```

> **생각해보기:** `/etc/hosts` 파일을 안 바꾸면 어떻게 되나요? 시스템이 안 켜질까요, 아니면 다른 문제가 생길까요?

시스템은 켜집니다. 하지만 `hostname`과 `/etc/hosts`의 불일치로 일부 서비스(특히 `sudo`)에서 "호스트를 해석할 수 없습니다" 경고가 발생할 수 있습니다.

---

## 17. 파티션 확인

```bash
lsblk
```

> **도전:** 출력의 **모든 줄**을 평가자에게 설명해보세요. `sda`, `sda1`, `sda2`, `sda5`, 암호화 장치, 각 LV의 이름과 마운트 포인트. 하나라도 설명 못 하면 5번 섹션으로 돌아가세요.

---

## 18. sudo 검증

```bash
dpkg -l | grep sudo    # 설치 확인
```

```bash
ls /var/log/sudo/
cat /var/log/sudo/sudo.log
```

> **실험:** `sudo ls /root`를 실행한 뒤, 다시 로그 파일을 확인하세요. 새 항목이 추가되었나요? 로그에 기록된 정보에는 무엇이 있나요? (시간, 사용자, 명령어, 작업 디렉터리...)

---

## 19. UFW 조작

```bash
sudo ufw status numbered    # 현재 규칙
```

> **예측하기:** 포트 4242에 대한 규칙이 몇 개 보이나요? IPv4와 IPv6 각각 있다면 2개일 것입니다.

```bash
sudo ufw allow 8080          # 추가
sudo ufw status numbered     # 확인
```

> **예측하기:** 8080 규칙은 목록의 어디에 추가되었나요? 번호는?

```bash
sudo ufw delete <번호>       # 삭제 (IPv4)
sudo ufw delete <번호>       # 삭제 (IPv6 — 번호 주의, 하나 삭제하면 밀림)
sudo ufw status numbered     # 원복 확인
```

> **함정:** 첫 번째 규칙을 삭제하면 나머지 번호가 **재배치**됩니다. 삭제할 때마다 `status numbered`로 번호를 다시 확인하세요.

---

## 20. SSH 검증

```bash
dpkg -l | grep ssh    # 설치 확인
```

**호스트 터미널에서:**

```bash
ssh <your_login>@127.0.0.1 -p 4242
# (또는 포트 포워딩 설정에 따른 호스트 포트)
```

```bash
ssh root@127.0.0.1 -p 4242
```

> **예측하기:** 두 번째 명령의 결과는? `Permission denied`가 나와야 합니다. 왜 root 접속이 차단되어야 하는지 6번 섹션에서 다룬 이유를 떠올려보세요.

---

## 21. 모니터링 스크립트

```bash
cat /etc/cron.d/monitoring.sh
# (또는 본인이 저장한 경로)
```

> **도전:** 스크립트의 각 줄을 읽으면서, 해당 명령어를 **직접 터미널에서 실행**해보세요. 스크립트에 적힌 명령어와 출력의 관계를 직접 눈으로 확인하세요.

| 스크립트 내 명령어 | 직접 실행해보기 | 출력이 스크립트 결과와 일치하나? |
|---|---|---|
| `uname -a` | 터미널에서 실행 | Architecture 줄과 비교 |
| `lscpu \| grep Socket` | 터미널에서 실행 | Physical CPU 수와 비교 |
| `nproc` | 터미널에서 실행 | vCPU 수와 비교 |
| `free -m` | 터미널에서 실행 | Memory Usage와 비교 |
| `df -h` | 터미널에서 실행 | Disk Usage와 비교 |
| `who -b` | 터미널에서 실행 | Last boot와 비교 |
| `ss -t state established` | 터미널에서 실행 | TCP Connections와 비교 |

스크립트의 모든 줄을 이렇게 한 번 뜯어보면, 평가자가 아무 줄이나 짚어 물어도 답할 수 있습니다.

---

## 22. cron 주기 변경

```bash
sudo crontab -u root -e
```

`*/10`을 `*/1`로 변경하고 저장합니다.

> **관찰하기:** 약 1분 후, 터미널에 메시지가 표시되나요? `wall` 명령어가 모든 터미널에 브로드캐스트하므로, 열린 모든 세션에서 볼 수 있어야 합니다.

> **마지막 생각:** `*/1`과 `1`의 차이는 뭘까요?
> - `*/1 * * * *` = 매 1분마다 (0분, 1분, 2분, ... = 사실상 `* * * * *`과 동일)
> - `1 * * * *` = 매 시 **1분**에만 (1:01, 2:01, 3:01, ...)

---

# 마무리

이 문서를 한 번 제대로 겪었다면, 평가자의 질문에 외운 답을 **낭송**하는 것이 아니라 자기 언어로 **설명**할 수 있어야 합니다.

최종 자기 진단: 아래 질문에 이 문서를 보지 않고 답해보세요.

1. 가상 머신이 뭐야? 왜 쓰는 거야?
2. Debian을 왜 골랐어?
3. apt와 aptitude가 다른 게 뭐야?
4. AppArmor가 뭐하는 건지 한 문장으로 말해봐.
5. 파티션은 왜 나누는 거야? LVM은 거기에 뭘 더해주는 거야?
6. root로 직접 로그인하면 안 되는 이유가 뭐야?
7. 방화벽은 뭘 하는 거고, 포트가 뭐야?
8. SSH가 왜 필요해? 포트를 22에서 바꾸는 게 진짜 보안이야?
9. cron이 뭐야? 스크립트를 안 건드리고 어떻게 멈춰?
10. 비밀번호를 10자 이상으로 하는 게 왜 중요해? `PASS_MIN_DAYS`는 왜 있어?

하나라도 막히면, 해당 섹션으로 돌아가서 **생각해보기** 구간을 다시 겪으세요.

막히지 않으면 — 이미 당신은 이것을 **이해**한 겁니다.
