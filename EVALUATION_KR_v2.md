# Born2beroot 동료 평가 대비 가이드 ✦ 인터랙티브 에디션

> **⚠️ 이 문서의 계약서**
>
> 이 문서는 읽는 것이 아니라 **겪는** 것입니다.
>
> - `🤔 생각해보기` → 반드시 **멈추고**, 머릿속으로 답을 완성한 뒤 클릭
> - `🔍 확인하기` → 클릭 전에 이미 답을 가지고 있어야 함
> - 답을 먼저 보면 → **이 문서의 가치는 0**
>
> 뇌는 **정답을 받을 때**가 아니라 **틀릴 위험을 감수하며 추론할 때** 가장 강하게 활성화됩니다.
> 불편함을 느끼는 그 순간이 학습이 일어나는 순간입니다.
>
> [Born2beroot 42 가이드 (한국어)](README_KR.md)와 함께 사용하세요.

---

## 목차

**1부: 개념을 내 것으로 만들기**
1. [가상 머신 — 컴퓨터 안의 컴퓨터](#1-가상-머신--컴퓨터-안의-컴퓨터)
2. [운영체제 선택 — 왜 Debian인가](#2-운영체제-선택--왜-debian인가)
3. [apt vs aptitude — 택배 기사의 차이](#3-apt-vs-aptitude--택배-기사의-차이)
4. [AppArmor — 보디가드는 어떻게 일하는가](#4-apparmor--보디가드는-어떻게-일하는가)
5. [파티션과 LVM — 왜 방을 나누는가](#5-파티션과-lvm--왜-방을-나누는가)
6. [sudo — 열쇠가 아니라 허가증이다](#6-sudo--열쇠가-아니라-허가증이다)
7. [UFW — 문은 왜 잠그는가](#7-ufw--문은-왜-잠그는가)
8. [SSH — 비밀 통로로 말하기](#8-ssh--비밀-통로로-말하기)
9. [cron — 알람시계의 원리](#9-cron--알람시계의-원리)
10. [비밀번호 정책 — 귀찮음의 이유](#10-비밀번호-정책--귀찮음의-이유)

**2부: 손으로 증명하기**
11. [평가 전 점검](#11-평가-전-점검)
12. [서명 검증](#12-서명-검증)
13. [서비스 상태 확인](#13-서비스-상태-확인)
14. [사용자와 그룹](#14-사용자와-그룹)
15. [비밀번호 정책 시연](#15-비밀번호-정책-시연)
16. [호스트명 변경](#16-호스트명-변경)
17. [파티션 확인](#17-파티션-확인)
18. [sudo 검증](#18-sudo-검증)
19. [UFW 조작](#19-ufw-조작)
20. [SSH 검증](#20-ssh-검증)
21. [모니터링 스크립트](#21-모니터링-스크립트)
22. [cron 주기 변경](#22-cron-주기-변경)

---

# 1부: 개념을 내 것으로 만들기

---

## 1. 가상 머신 — 컴퓨터 안의 컴퓨터

### 출발점

지금 당신 앞에 노트북이 있습니다. macOS든 Windows든 리눅스든, 하나의 운영체제가 돌아가고 있죠.

---

> 🤔 **생각해보기 — 직접 답을 구성한 뒤 클릭하세요**
>
> 지금 이 노트북 위에서 동시에 Debian 리눅스도 실행하고 싶습니다.
> 떠오르는 **모든** 방법을 열거해보세요. 현실적인 것도, 황당한 것도 다 괜찮습니다.

<details>
<summary>🔍 내가 생각한 것과 비교하기</summary>

가능한 방법들:

| 방법 | 한계 |
|------|------|
| 노트북을 하나 더 산다 | 비용, 공간 |
| USB 라이브 부팅 | 재부팅 필요, 느림, 데이터 유지 어려움 |
| 듀얼부팅 (파티션 분리) | 한 번에 하나만, 재부팅 필요 |
| **소프트웨어로 가짜 컴퓨터를 만든다** | → 이것이 가상 머신 |

"소프트웨어로 가짜 컴퓨터를 만든다"는 아이디어가 있었나요? 있었다면, 이미 가상 머신의 본질을 직관적으로 이해한 겁니다.

</details>

---

### 핵심 아이디어

가상 머신은 **소프트웨어가 하드웨어인 척하는 것**입니다.

실제 CPU가 하나인데, 소프트웨어가 "여기 CPU 두 개 있어요"라고 거짓말합니다. 실제 RAM이 16GB인데, "당신에게 4GB 드릴게요"라고 나눠줍니다. 게스트 OS는 이 거짓말을 믿고, 진짜 컴퓨터 위에서 돌아가는 것처럼 행동합니다.

이 거짓말을 관리하는 소프트웨어가 **하이퍼바이저(Hypervisor)** 입니다.

### Type 1 vs Type 2

---

> 🤔 **생각해보기**
>
> 하이퍼바이저가 거짓말쟁이라면, 이 거짓말쟁이가 **어디에 서 있는지**가 성능을 결정합니다.
> 두 가지 위치가 가능합니다. 각각의 장단점은 무엇일까요?
> (힌트: 중간 다리가 있을수록 어떻게 되나요?)

<details>
<summary>🔍 확인하기</summary>

**Type 1 — 베어메탈(Bare-metal) 하이퍼바이저:**

```
[ 하드웨어 ]
      ↓
[ 하이퍼바이저 ]  ← 중간 다리 없이 직접 제어
      ↓         ↓
[ VM1 ]      [ VM2 ]
```

운영체제 없이, 하이퍼바이저가 하드웨어를 직접 제어합니다. 중간 레이어가 없으니 빠릅니다. 데이터센터 서버에서 사용합니다. (VMware ESXi, Proxmox, Hyper-V)

**Type 2 — 호스티드(Hosted) 하이퍼바이저:**

```
[ 하드웨어 ]
      ↓
[ 호스트 OS (macOS/Windows) ]
      ↓
[ 하이퍼바이저 앱 (VirtualBox) ]
      ↓
[ 게스트 OS (Debian) ]
```

호스트 OS 위에서 **앱으로** 돌아갑니다. 우리가 쓰는 VirtualBox가 이것입니다. 호스트 OS가 먼저 자원을 먹고 남는 것을 나눠 받으므로 느리지만, **기존 작업 환경을 유지**하면서 VM을 쓸 수 있습니다.

</details>

---

> 🤔 **생각해보기**
>
> Type 1이 더 빠른데 왜 우리는 Type 2인 VirtualBox를 쓸까요?
> 그리고 Type 2가 가진 **근본적인 성능 한계**는 무엇인가요? 구조를 보면 답이 보입니다.

<details>
<summary>🔍 확인하기</summary>

**왜 우리는 Type 2를 쓰는가:**

42 클러스터의 iMac은 이미 macOS가 돌아가고 있습니다. Type 1은 전용 서버에서 OS 대신 설치해야 합니다. 기존 OS를 유지하면서 VM을 돌리려면 Type 2가 유일한 선택입니다.

**Type 2의 근본적 한계:**

호스트 OS가 먼저 자원(CPU 사이클, 메모리)을 가져간 뒤, 남은 것을 VM에 줍니다. 즉, VM은 항상 **2등 시민**입니다. CPU 가상화 레이어도 하나 더 있어서, 동일한 작업도 Type 1보다 더 많은 사이클을 소모합니다.

</details>

---

### 가상 머신을 쓰는 이유

---

> 🤔 **생각해보기**
>
> 듀얼부팅으로도 두 OS를 쓸 수 있는데, 왜 굳이 가상 머신을 쓸까요?
> 듀얼부팅으로는 **절대 불가능**하지만, 가상 머신으로는 **가능한 것** 세 가지를 말해보세요.

<details>
<summary>🔍 확인하기</summary>

핵심은 **동시 실행**, **격리**, **스냅샷**입니다.

| 기능 | 듀얼부팅 | 가상 머신 |
|------|---------|----------|
| 동시에 두 OS 실행 | ❌ 불가 | ✅ 가능 |
| 한 OS에서 다른 OS로 파일 복사 | ⚠️ 재부팅 필요 | ✅ 실시간 |
| 실수로 시스템 망가뜨렸을 때 복구 | ❌ 고통스러움 | ✅ 스냅샷으로 즉시 복원 |
| 게스트 안에서 `rm -rf /` 실행 | ❌ 호스트도 영향 받을 수 있음 | ✅ 호스트 완전 안전 |

**스냅샷**: 게임의 세이브 포인트와 같습니다. "지금 이 상태를 저장해둬" 하고 찍어두면, 나중에 무슨 짓을 해도 그 시점으로 돌아올 수 있습니다.

</details>

---

### 🧠 즉문즉답 카드 — 입으로 소리 내어 답하세요

아래 질문을 보고, **클릭 전에 입으로 완전한 문장으로 답해보세요.**
답이 나오지 않으면, 위 섹션으로 돌아가세요.

<details>
<summary>① "가상 머신이 뭐야?" — 30초 안에 한 문장으로</summary>

**모범 답안:** "가상 머신은 소프트웨어가 하드웨어인 척해서 실제 컴퓨터 위에서 가짜 컴퓨터를 실행하는 기술입니다."

**핵심 키워드가 있어야 합니다:** 소프트웨어, 하드웨어인 척, 격리

</details>

<details>
<summary>② VirtualBox는 Type 몇이고, 그 의미는?</summary>

**Type 2.** 호스트 OS(macOS/Windows) 위에서 앱으로 동작합니다. 즉, 호스트 OS가 먼저 자원을 가져가고 남은 것을 VM이 사용합니다. 성능은 Type 1보다 낮지만, 기존 작업 환경을 유지할 수 있습니다.

</details>

<details>
<summary>③ 가상 머신이 Docker 컨테이너와 다른 점은? (핵심 하나만)</summary>

**커널 공유 여부.**

- 가상 머신: 게스트 OS가 자체 커널을 가짐 → 완전한 격리, 무거움
- Docker: 호스트 커널을 공유 → 격리 불완전, 가벼움

VM에서는 Linux 커널 위에 Windows를 올릴 수 있지만, Docker는 호스트와 동일한 커널(Linux)을 써야 합니다.

</details>

---

## 2. 운영체제 선택 — 왜 Debian인가

### 선택지

Born2beroot은 **Debian** 또는 **Rocky Linux** 중 하나를 선택하게 합니다.

---

> 🤔 **생각해보기**
>
> 아래 두 사실만을 단서로, Debian과 Rocky Linux의 **성격 차이**를 추론해보세요.
> 추론 과정을 머릿속으로 소리 내어 말해보세요.
>
> - 단서 1: Ubuntu는 Debian을 기반으로 만들어졌다
> - 단서 2: Rocky Linux는 기업이 유료로 쓰던 Red Hat Enterprise Linux(RHEL)의 소스코드로 만들어졌다

<details>
<summary>🔍 추론 결과 확인하기</summary>

**추론 과정:**

- Ubuntu(개인/일반)의 베이스 = Debian → Debian은 **범용·커뮤니티 지향**
- RHEL(기업·유료)의 소스 = Rocky Linux → Rocky는 **기업 환경·안정성·보수적**

**두 갈래의 리눅스 세계:**

| | Debian 계열 | RHEL 계열 |
|--|------------|----------|
| 대표 | Debian → Ubuntu → Linux Mint | RHEL → CentOS(사망) → Rocky/AlmaLinux |
| 패키지 | `.deb` | `.rpm` |
| 패키지 관리 | `apt` / `aptitude` | `dnf` (구 `yum`) |
| 보안 모듈 | **AppArmor** | **SELinux** |
| 방화벽 | **UFW** | **firewalld** |
| 성격 | 커뮤니티·범용·안정 | 기업·장기지원·보수적 업데이트 |

</details>

---

> 🤔 **생각해보기**
>
> 프로젝트 서브젝트에 "시스템 관리가 처음이라면 Debian을 추천한다"고 적혀 있습니다.
> 위 표를 보면서, **왜 초보자에게 Debian인지** 2-3가지 이유를 스스로 도출해보세요.
> (표를 다시 보세요. 각 항목이 초보자에게 어떤 의미인지 생각해보세요.)

<details>
<summary>🔍 확인하기</summary>

1. **AppArmor vs SELinux 진입장벽:** AppArmor는 경로 기반 규칙으로 직관적입니다. SELinux는 레이블 기반으로 개념 자체가 낯설고, 설정 오류 시 디버깅이 매우 어렵습니다.

2. **UFW vs firewalld 단순성:** UFW는 `ufw allow 4242` 같은 단순한 명령으로 동작합니다. firewalld는 zone 개념을 이해해야 합니다.

3. **커뮤니티 문서:** Ubuntu가 Debian 기반이므로, Ubuntu 문서가 대부분 Debian에도 적용됩니다. 검색 결과가 압도적으로 많습니다.

4. **전이 가치:** Debian을 배우면 Ubuntu, Linux Mint 등 거의 모든 Debian 계열에 적용됩니다. 시장 점유율이 높습니다.

</details>

---

### 평가에서 이렇게 답하세요

"왜 Debian을 선택했나요?"라는 질문에 비교표를 외워서 읊는 것이 아닙니다.

---

> 🤔 **생각해보기 — 30초 말하기 훈련**
>
> 이 문서를 닫고, 실제 평가자 앞이라고 상상하며 "왜 Debian을 선택했나요?"에 답하세요.
> 외운 것이 아닌, **자기 언어**로. 30초 이내로.

<details>
<summary>🔍 모범 답안 구조 확인하기</summary>

좋은 답변의 구조:

> "시스템 관리가 처음이라 진입장벽이 낮은 쪽을 택했습니다. Debian은 APT 생태계와 AppArmor, UFW 등 비교적 직관적인 도구를 쓰고, 커뮤니티 자료도 풍부합니다. 또한 Ubuntu의 기반이기 때문에, 여기서 배운 것이 나중에도 쓸모가 있다고 판단했습니다."

**평가자가 듣고 싶은 것:** "이 사람이 선택의 이유를 이해하고 있는가?" vs "그냥 따라 설치했는가?"

핵심은 **비교를 통한 선택의 논리**입니다.

</details>

---

## 3. apt vs aptitude — 택배 기사의 차이

### 비유로 시작

리눅스에서 소프트웨어를 설치한다는 것은, **패키지**라는 택배 상자를 받아서 여는 것과 같습니다. 그런데 택배 상자에는 종종 이런 쪽지가 붙어 있습니다: "이 상자를 열려면 먼저 A 상자와 B 상자가 필요합니다." 이것이 **의존성(dependency)** 입니다.

**apt**와 **aptitude**는 둘 다 이 택배를 배달해주는 기사입니다. 하지만 일하는 방식이 다릅니다.

### apt — 직선적인 기사

`apt`는 단순합니다. "X 설치해줘" 하면 X와 그 의존성을 다운로드하고 설치합니다. 의존성 충돌이 생기면?

```
다음 패키지에 충족할 수 없는 의존성이 있습니다:
  패키지A: 의존: 패키지B (>= 2.0) 하지만 1.8 버전이 설치됨
E: 오류, 설치할 수 없습니다
```

apt는 **"안 돼요, 못 해요"** 하고 멈춥니다. 해결은 당신 몫입니다.

### aptitude — 해결사 기사

`aptitude`는 같은 상황에서 다르게 행동합니다:

```
다음 동작이 의존성 문제를 해결합니다:
  해결책 1: 패키지B를 2.0으로 업그레이드
  해결책 2: 패키지A를 설치하지 않음
  해결책 3: 패키지C를 제거하고 패키지B 2.0을 설치

이 해결책을 수락하시겠습니까? [Y/n/q/?]
```

aptitude는 **여러 해결 방안을 제시**합니다. 또한 ncurses 기반의 텍스트 UI도 제공하고, 사용하지 않게 된 패키지를 자동으로 추적하여 제거를 제안합니다.

---

> 🤔 **생각해보기**
>
> aptitude가 더 스마트해 보이는데, 그렇다면 왜 apt를 쓰는 경우가 더 많을까요?
> 반대로 aptitude가 **오히려 위험해질 수 있는** 상황을 상상해보세요.

<details>
<summary>🔍 확인하기</summary>

**apt가 더 적합한 경우:**

1. **자동화 스크립트:** `apt`는 충돌 시 오류코드를 리턴하고 멈춥니다. 예측 가능합니다. `aptitude`는 "해결책 3: 패키지C를 제거하고..." 같은 결정을 내릴 수 있는데, 스크립트가 자동으로 "Y"를 입력하면 의도치 않은 삭제가 발생합니다.

2. **기본 설치 여부:** Debian에 `apt`는 기본 설치. `aptitude`는 `apt install aptitude`로 따로 설치해야 합니다.

**aptitude가 위험해지는 시나리오:**

aptitude가 "패키지C를 삭제하면 해결됩니다"라고 제안했는데, 그 패키지C가 프로덕션 서버의 핵심 서비스였다면? 스마트한 도구도 **컨텍스트를 모릅니다**. 의존성 그래프만 보고 결정하기 때문에, 인간이 알고 있는 "이 패키지는 절대 건드리면 안 돼"를 모릅니다.

**결론:** 일상적인 패키지 관리 = apt. 복잡한 의존성 충돌 해결 = aptitude. 스크립트/자동화 = apt.

</details>

---

### 🧠 시나리오 문제 — 클릭 전에 반드시 답을 정해두세요

> **시나리오:**
> 패키지 X를 설치하려는데, X는 Y 버전 2.0 이상을 필요로 합니다. 그런데 이미 설치된 Z가 Y 버전 1.x를 필요로 합니다. Y를 올리면 Z가 깨집니다.

<details>
<summary>apt의 반응은? (답 정하고 클릭)</summary>

**"안 돼요"** 하고 에러 메시지를 출력하고 멈춥니다. 해결 방법을 제시하지 않습니다. 당신이 직접 수동으로 해결해야 합니다.

</details>

<details>
<summary>aptitude의 반응은? (답 정하고 클릭)</summary>

세 가지 이상의 해결 방안을 제시합니다: Y를 올리고 Z를 업데이트, X를 포기, Z를 제거... 등. 사용자가 선택합니다.

</details>

<details>
<summary>이 상황에서 당신은 어떤 도구를 선택하고, 왜? (답 정하고 클릭)</summary>

**상황에 따라 다릅니다.** 이것이 정답입니다.

- 개발 환경, 충돌 해결이 목적 → aptitude로 옵션을 보고 판단
- 프로덕션, 신중하게 수동 제어 원함 → apt로 에러 확인 후 무엇을 건드릴지 직접 결정
- 자동화 CI/CD → apt (예측 가능성)

</details>

---

## 4. AppArmor — 보디가드는 어떻게 일하는가

### 문제 상황

---

> 🤔 **생각해보기**
>
> 당신이 서버 관리자입니다. nginx 웹 서버에 보안 취약점이 생겨 공격자가 nginx **프로세스**를 장악했습니다.
> 공격자는 이제 nginx의 권한으로 뭐든 할 수 있습니다.
>
> 질문 1: nginx가 **정상적으로** 하는 일은 무엇인가요?
> 질문 2: nginx가 **절대 해서는 안 되는** 일은 무엇인가요?
> 
> 이 두 목록을 먼저 작성해보세요.

<details>
<summary>🔍 확인 및 이것이 왜 AppArmor와 연결되는지</summary>

**nginx가 정상적으로 하는 일:**
- `/var/www/html` 에서 웹 파일 읽기
- 포트 80, 443에서 HTTP/HTTPS 요청 받기
- `/var/log/nginx/`에 로그 쓰기
- `/etc/nginx/`에서 설정 파일 읽기

**nginx가 절대 해서는 안 되는 일:**
- `/etc/shadow` (비밀번호 해시 파일) 읽기
- `/home` 디렉터리 뒤지기
- 임의의 새 프로세스 생성 (`/bin/bash` 실행 등)
- 새로운 외부 네트워크 연결 개시

**AppArmor의 역할:**

이 "해야 하는 일"과 "하면 안 되는 일"의 목록을 **프로파일(profile)** 로 만들어 강제합니다. 공격자가 nginx를 장악해도, AppArmor가 프로파일 밖의 행동을 차단합니다.

→ 프로그램이 뚫려도 **피해 범위가 프로파일로 제한**됩니다.

</details>

---

### AppArmor의 원리

AppArmor는 각 프로그램에 **프로파일(profile)** 이라는 허가증을 붙입니다.

```
# nginx의 AppArmor 프로파일 (개념적 예시)
/usr/sbin/nginx {
    /var/www/html/** r,          # 웹 파일 읽기 허용
    /var/log/nginx/** w,         # 로그 쓰기 허용
    /etc/nginx/** r,             # 설정 파일 읽기 허용
    network inet tcp,            # TCP 네트워크 허용

    # 그 외 모든 것은 거부됨
}
```

### 경로 기반 vs 레이블 기반

AppArmor는 **경로(path)** 를 봅니다: "이 파일은 `/var/www/html`에 있으니까 허용."

반면 SELinux(Rocky Linux에서 사용)는 **레이블(label)** 을 봅니다: "이 파일에 `httpd_content_t`라는 꼬리표가 붙어 있으니까 허용."

---

> 🤔 **생각해보기 — 핵심 차이 테스트**
>
> 웹 파일 `/var/www/html/index.html`을 `/tmp/index.html`로 이동했습니다.
> AppArmor와 SELinux는 각각 nginx가 이 파일을 읽으려 할 때 어떻게 반응할까요?
>
> 각각의 메커니즘(경로 vs 레이블)을 생각하면 답이 나옵니다.

<details>
<summary>🔍 확인하기</summary>

**AppArmor (경로 기반):**
파일이 `/var/www/html/**` → `/tmp/index.html`로 이동했습니다. 경로가 바뀌었으므로, nginx 프로파일에 `/tmp/**` 규칙이 없다면 **접근 차단**됩니다.

**SELinux (레이블 기반):**
`mv` 명령으로 이동하면 파일에 붙은 `httpd_content_t` 레이블이 **함께 이동**합니다. SELinux는 레이블을 보므로, 파일이 `/tmp`에 있어도 레이블이 유지되면 **접근 허용**됩니다.

(단, `cp`로 복사하면 대상 디렉터리의 레이블을 상속하므로 레이블이 바뀝니다.)

**왜 이 차이가 중요한가:**

- AppArmor (경로 기반): 직관적, 설정 쉬움, 파일을 옮기면 보안 정책에서 벗어날 수 있음
- SELinux (레이블 기반): 파일이 어디로 가든 보안 정책이 따라다님, 더 견고하지만 복잡

이것이 SELinux가 "강력하지만 어렵다"고 평가받는 이유입니다.

</details>

---

### enforce vs complain

```bash
sudo aa-status
```

- **enforce**: 규칙 위반을 **실제로 차단**. 실전 모드.
- **complain**: 위반을 **로그에 기록만**. 연습/디버깅 모드.

---

> 🤔 **생각해보기**
>
> complain 모드는 왜 존재할까요? "차단하지 않는다면 보안에 의미 없는 것 아닌가?"라고 생각했다면, 어떤 상황에서 complain이 필수적인지 생각해보세요.

<details>
<summary>🔍 확인하기</summary>

**시나리오: 새 프로파일 작성**

새 프로그램 `myapp`에 AppArmor 프로파일을 만들어야 합니다. 이 프로그램이 실행 중에 정확히 어떤 파일에 접근하는지 모릅니다.

- **처음부터 enforce로 실행하면:** 프로파일에 누락된 경로가 있으면 프로그램이 동작하지 않습니다. 무엇이 차단됐는지 알기 어렵습니다.

- **complain 모드로 먼저 실행하면:** 프로그램이 정상 동작하면서, "이 경로에 접근하려 했으나 프로파일에 없습니다"가 로그에 쌓입니다. 로그를 보고 필요한 경로를 파악하여 프로파일을 완성한 뒤 enforce로 전환합니다.

**결론:** complain은 "프로파일 개발 중" 상태입니다. 보안보다 관찰이 목적입니다.

</details>

---

## 5. 파티션과 LVM — 왜 방을 나누는가

### 방 하나짜리 집

---

> 🤔 **생각해보기**
>
> 원룸(방 하나)에 삽니다. 침대, 책상, 주방, 옷장이 모두 같은 공간에 있습니다.
> 이것의 **구체적인 문제**는 무엇인가요?
> 이 비유를 디스크 파티션 하나짜리 서버에 **직접 대응**시켜보세요.

<details>
<summary>🔍 확인하기</summary>

**원룸의 문제 → 파티션 하나의 문제:**

| 원룸 상황 | 파티션 하나 상황 |
|----------|----------------|
| 요리하다 기름이 튀면 침대에 묻음 | 사용자가 `/home`에 대용량 파일을 받으면 OS 로그도 못 씀 |
| 손님이 오면 주방 지저분한 것도 보임 | 한 파티션 손상 → 전체 시스템 손상 |
| 한 영역 문제가 전체에 영향 | `/var/log` 폭주 → OS 전체 마비 |

**실제 사고 시나리오:**

사용자가 `/home`에 4K 영상을 다운로드합니다. 루트(`/`)와 같은 파티션이라면, 디스크가 꽉 찹니다. 그러면 시스템 로그(`/var/log`)도 더 이상 쓸 수 없고, OS 자체가 멈출 수 있습니다.

</details>

---

### 방을 나누면

파티션을 나누면 각 영역이 **독립**됩니다:

| 파티션 | 마운트 포인트 | 역할 | 왜 분리하는가 |
|--------|-------------|------|-------------|
| boot | `/boot` | 부트로더, 커널 | 부팅에 필수적인 파일이 다른 영향을 받지 않도록 |
| root | `/` | 운영체제 핵심 | OS의 핵심 파일 보호 |
| home | `/home` | 사용자 데이터 | 사용자가 디스크를 채워도 OS에 영향 없음 |
| var | `/var` | 로그, 캐시 | 로그 폭주가 OS를 죽이지 않도록 |
| tmp | `/tmp` | 임시 파일 | 임시 파일이 넘쳐도 다른 영역은 안전 |
| swap | [swap] | 가상 메모리 | RAM이 부족할 때 디스크를 메모리처럼 사용 |

---

> 🤔 **생각해보기 — 보안 시나리오**
>
> 공격자가 서버에 침투해서, `/var/log`를 무한히 생성하는 프로세스를 심었습니다.
>
> - Case A: `/var`가 루트(`/`)와 같은 파티션일 때 무슨 일이 벌어지나요?
> - Case B: `/var`가 별도 파티션으로 분리되어 있다면?
>
> 각각의 결말을 구체적으로 상상해보세요.

<details>
<summary>🔍 확인하기</summary>

**Case A — 분리 안 됨:**

로그가 쌓이면서 루트 파티션(`/`)을 가득 채웁니다. 루트가 꽉 차면:
- 새 프로세스 생성 불가 (임시 파일 못 씀)
- 패스워드 변경 불가
- sudo 사용 불가 (로그 기록 못 씀)
- 시스템이 사실상 **마비**됩니다

공격자가 코드를 전혀 실행하지 않고, 로그 생성만으로 서버를 멈춘 것입니다. 이것이 **Disk Exhaustion 공격**입니다.

**Case B — 분리됨:**

`/var` 파티션만 가득 찹니다. 루트(`/`)는 여전히 공간이 있으므로:
- OS는 정상 동작
- SSH 접속 가능
- `/var`만 마운트 해제하거나 로그를 정리하면 복구 가능

분리가 **피해 범위를 제한**합니다. AppArmor의 원리와 같은 철학입니다.

</details>

---

### LVM — 리모델링이 가능한 벽

전통적인 파티션은 **콘크리트 벽**입니다. 한번 정하면 바꾸기 매우 어렵습니다.

LVM(Logical Volume Manager)은 **이동식 칸막이**입니다.

```
물리 디스크(PV) → 하나의 큰 공간으로 합침(VG) → 원하는 대로 나눔(LV)

Physical Volume    Volume Group          Logical Volume
실제 디스크/파티션 → 저장소 풀(수영장)   → 가상 파티션(레인)
```

---

> 🤔 **생각해보기**
>
> 방 비유를 이어갑시다. 처음에 서재에 2평을 줬는데, 책이 늘어서 4평이 필요합니다.
>
> - 콘크리트 벽이면 어떻게 해야 하나요? (현실적으로 생각해보세요)
> - 이동식 칸막이면?
>
> 이것을 서버 운영 관점에서 어떻게 번역하면 될까요?

<details>
<summary>🔍 확인하기</summary>

**콘크리트 벽 (전통 파티션):**

서재를 2평 → 4평으로 늘리려면: 벽을 부수고 다시 치기. 서버로 번역하면: 시스템 중단 → 데이터 백업 → 재포맷 → 재설치 → 데이터 복원. 프로덕션 서버에서는 수 시간 ~ 수 일의 다운타임이 발생합니다.

**이동식 칸막이 (LVM):**

칸막이를 옆으로 밀어서 서재를 넓힘. 서버로 번역하면: `lvextend -L +2G /dev/vg/home && resize2fs /dev/vg/home` — **시스템이 살아있는 동안 즉시** 볼륨 크기 변경. 다운타임 없음.

이것이 서버 환경에서 LVM이 사실상 표준인 이유입니다.

**추가 LVM의 장점:**

- 여러 물리 디스크를 하나의 논리 볼륨으로 합칠 수 있음 (JBOD)
- 스냅샷 기능 (백업 시 유용)
- 볼륨을 줄일 수도 있음 (단, 줄이는 것은 데이터 손실 위험으로 주의 필요)

</details>

---

### 암호화

Born2beroot에서는 **암호화된 LVM**을 사용합니다.

---

> 🤔 **생각해보기**
>
> 파티션을 암호화한다는 것은 구체적으로 무엇을 의미할까요?
> **누구로부터** 무엇을 보호하는 건지 정확히 말해보세요.
> 힌트: "인터넷 해커"로부터 보호하는 건가요, 아니면 다른 대상이 있나요?

<details>
<summary>🔍 확인하기</summary>

**암호화는 물리적 접근에 대한 방어입니다.**

시나리오: 데이터센터에 누군가 침입해서 서버의 하드디스크를 빼갔습니다.

- **암호화 없음:** 그 디스크를 다른 컴퓨터에 꽂으면 모든 데이터를 그냥 읽을 수 있습니다. OS 로그인이 필요 없습니다. 파일 시스템을 마운트하면 끝입니다.

- **LUKS 암호화 있음:** 디스크를 꽂아도 내용이 무작위 바이트로 보입니다. 올바른 패스프레이즈 없이는 해독 불가능합니다.

**인터넷 공격자로부터는?**

그것은 방화벽(UFW), SSH 설정, sudo 등이 담당합니다. 암호화는 **디스크를 물리적으로 획득한 경우**에 대한 방어입니다. 보안의 레이어가 각각 다른 위협을 담당합니다.

**부팅 시 패스프레이즈 요구가 이것을 의미합니다.** 암호화된 LUKS 볼륨을 열기 위해 매 부팅마다 키를 입력해야 합니다.

</details>

---

### 🧠 lsblk 출력 해석 카드

VM에서 `lsblk`를 실행하면 이런 출력이 나옵니다. 각 항목의 의미를 클릭 전에 말해보세요.

<details>
<summary>① sda는 무엇인가?</summary>

**물리 디스크 전체.** `sd` = SCSI/SATA 디스크, `a` = 첫 번째 디스크. 두 번째라면 `sdb`.

</details>

<details>
<summary>② sda1, sda2 등은 무엇인가?</summary>

**물리 파티션.** `sda1` = 첫 번째 물리 파티션. Born2beroot에서는 보통 `sda1` = `/boot`, `sda2` = LUKS 암호화 컨테이너.

</details>

<details>
<summary>③ crypt 붙은 것은 무엇인가?</summary>

**LUKS로 열린 암호화 컨테이너.** `sda2`를 패스프레이즈로 열면 이 논리 장치가 나타납니다. 이 안에 LVM이 있습니다.

</details>

<details>
<summary>④ lvm 붙은 것은 무엇인가?</summary>

**LVM의 논리 볼륨(LV).** LUKS 컨테이너 안의 VG에서 나눈 논리 파티션들입니다. 각각 `/`, `/home`, `/var` 등에 마운트됩니다.

</details>

<details>
<summary>⑤ 왜 어떤 것은 type=part 이고 어떤 것은 type=lvm 인가?</summary>

- `part`: 실제 물리 파티션 (파티션 테이블에 기록된 것)
- `lvm`: LVM이 관리하는 논리 볼륨 (파티션 테이블에 없음, LVM 메타데이터에 있음)

물리 디스크 → 물리 파티션(part) → LUKS 암호화 → VG → 논리 볼륨(lvm) 순서입니다.

</details>

---

## 6. sudo — 열쇠가 아니라 허가증이다

### root라는 존재

리눅스에서 `root`는 **신**입니다. 모든 파일을 읽고, 모든 프로세스를 죽이고, 시스템을 포맷할 수도 있습니다. 제한이 없습니다.

---

> 🤔 **생각해보기**
>
> 그렇다면 왜 그냥 root로 로그인해서 작업하면 안 될까요?
> "편하잖아요?" 라는 반론에 대해, **세 가지 구체적인 위험**을 논리적으로 반박해보세요.

<details>
<summary>🔍 확인하기</summary>

**아파트 마스터키 비유:**

| 마스터키 항상 소지 | sudo 방식 |
|-------------------|----------|
| 실수로 엉뚱한 방 열 수 있음 | 일반 권한으로 실수해도 영향 제한 |
| 잃어버리면 건물 전체 위험 | 세션 탈취당해도 권한 제한 |
| 누가 어디 들어갔는지 추적 불가 | sudo 사용 시 로그에 기록 |

**세 가지 구체적 위험:**

1. **실수:** `rm -rf /tmp/my_dir` 을 치려다 `rm -rf /` 를 쳐도 root면 실행됩니다. 일반 사용자라면 권한 오류로 멈춥니다.

2. **탈취:** 공격자가 shell을 탈취했을 때, root shell이라면 게임 오버입니다. 일반 사용자 shell이라면 피해 범위가 제한됩니다.

3. **추적 불가:** root가 한 모든 것은 "root가 했음"으로 기록됩니다. 누가 실제로 무엇을 했는지 알 수 없습니다. sudo는 어떤 사용자가 어떤 명령을 실행했는지 개인별로 기록합니다.

이것이 **최소 권한 원칙(Principle of Least Privilege)** 입니다.

</details>

---

### Born2beroot의 sudo 설정을 뜯어보기

---

> 🤔 **생각해보기 — `Defaults requiretty`**
>
> TTY는 터미널입니다. sudo를 터미널에서만 쓸 수 있게 제한하는 것이 왜 보안에 도움이 될까요?
> "터미널이 아닌 곳에서 sudo를 실행하는 경우"가 어떤 경우인지 생각해보세요.

<details>
<summary>🔍 확인하기</summary>

**터미널 없이 sudo를 실행하는 경우:**

1. **웹 취약점 공격:** 웹 서버(nginx/Apache)의 취약점을 통해 명령 실행이 가능해진 공격자가, 터미널 없이 `sudo` 명령을 삽입합니다.

2. **악성 스크립트:** cron이나 systemd service로 실행되는 스크립트 안에서 sudo 호출.

3. **원격 코드 실행(RCE):** 터미널을 할당받지 않은 원격 명령 실행.

`requiretty`가 있으면 위 경우들이 모두 "No TTY present"로 거부됩니다. 인간이 물리적으로 터미널 앞에 앉아서 입력하도록 강제하는 것입니다.

</details>

---

> 🤔 **생각해보기 — `Defaults secure_path`**
>
> 공격자가 `/tmp/ls`라는 악성 프로그램을 만들고, PATH 앞에 `/tmp`를 추가해서 `sudo ls`를 치면 `/tmp/ls`가 실행되게 할 수 있습니다.
> `secure_path`가 이것을 어떻게 막을까요?

<details>
<summary>🔍 확인하기</summary>

`secure_path`는 sudo가 사용하는 PATH를 **하드코딩**합니다:

```
Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
```

사용자의 `$PATH` 환경 변수가 아무리 조작되어도, sudo는 항상 위에 지정된 경로에서만 프로그램을 찾습니다. `/tmp`가 PATH에 들어있어도 sudo는 무시합니다.

이것이 **PATH 하이재킹(PATH Hijacking)** 공격을 방지하는 방법입니다.

**추가 설정들:**

- `log_input`, `log_output`: sudo 세션에서 입력된 명령과 출력 결과를 모두 기록. 보안 감사 시 "어떤 명령을 쳤고 결과가 뭐였는지"까지 재현 가능.
- `passwd_tries=3`: 비밀번호 3번 실패 시 잠금. 브루트포스 방지.

</details>

---

## 7. UFW — 문은 왜 잠그는가

### 포트라는 개념

---

> 🤔 **생각해보기**
>
> 서버의 IP 주소가 하나인데, 웹 서버도 돌리고 SSH도 돌리고 이메일 서버도 돌립니다.
> 클라이언트가 같은 IP 주소로 접속할 때, 어떻게 "이 요청은 웹서버에, 저 요청은 SSH에" 구분할까요?

<details>
<summary>🔍 확인하기</summary>

**포트(port)** 입니다.

IP 주소가 건물 주소라면, 포트 번호는 **호실 번호**입니다. 같은 건물(IP)에서도 80호, 443호, 22호는 각기 다른 서비스를 하고 있습니다.

| 포트 번호 | 서비스 |
|-----------|--------|
| 80 | HTTP (웹) |
| 443 | HTTPS (보안 웹) |
| 22 | SSH (기본) |
| 25 | SMTP (이메일) |
| 4242 | Born2beroot SSH 이사 장소 |

총 65535개의 포트가 있습니다 (0번은 예약).

**TCP 헤더 구조:** 패킷에는 "출발지 포트"와 "목적지 포트"가 함께 담겨 있습니다. OS는 목적지 포트를 보고 어떤 프로세스에 전달할지 결정합니다.

</details>

---

### 방화벽이 필요한 이유

---

> 🤔 **생각해보기**
>
> 65535개의 방이 있는 건물에서 실제로 쓰는 방은 4242호 하나뿐입니다.
> 나머지 65534개의 문은 어떻게 해야 할까요?
> "그냥 아무도 안 들어오면 되지 않나?"라는 생각이 왜 틀렸는지 설명해보세요.

<details>
<summary>🔍 확인하기</summary>

**"아무도 안 들어오면 되지" 의 문제:**

인터넷에는 모든 IP의 모든 포트를 자동으로 스캔하는 봇이 24시간 돌아가고 있습니다. 당신의 서버가 열려있는지 닫혀있는지 탐색합니다. 열린 포트를 발견하면 알려진 취약점을 자동으로 시도합니다.

열린 문이 있으면 **언젠가는 누군가 시도합니다.** 가정이 아니라 현실입니다.

**UFW 설정:**

```bash
ufw default deny incoming     # 모든 문을 잠금 (기본 거부)
ufw default allow outgoing    # 나가는 것은 허용 (기본 허용)
ufw allow 4242                # 4242호만 열어둠
```

</details>

---

> 🤔 **생각해보기**
>
> `allow outgoing` — 나가는 트래픽은 왜 전부 허용할까요?
> "나가는 것도 막으면 더 안전하지 않나요?"라는 반론에 답해보세요.

<details>
<summary>🔍 확인하기</summary>

**나가는 트래픽을 막으면:**

- `apt update` 불가 (패키지 저장소 접속 차단)
- DNS 조회 불가 (도메인 이름 → IP 변환 불가)
- 시간 동기화(NTP) 불가
- 서버가 기능할 수 없습니다

**절충점:**

서버가 기능하려면 최소한의 아웃바운드 트래픽이 필요합니다. 극도로 민감한 환경(정부 보안 시스템 등)에서는 아웃바운드도 특정 IP/포트만 화이트리스트로 허용합니다. 그러나 이는 관리 비용이 매우 높습니다. Born2beroot 수준에서는 `allow outgoing`이 합리적입니다.

**UFW vs firewalld:**

둘 다 내부적으로 **iptables** (또는 nftables)라는 리눅스 커널의 패킷 필터링 시스템을 사용합니다. UFW와 firewalld는 이 복잡한 시스템을 인간이 쓸 수 있도록 감싼 **프론트엔드**일 뿐입니다. UFW = 규칙 목록 방식. firewalld = zone 방식.

</details>

---

## 8. SSH — 비밀 통로로 말하기

### 왜 필요한가

---

> 🤔 **생각해보기**
>
> 카페에서 노트북으로 서버에 접속합니다. 같은 와이파이를 쓰는 옆자리 사람이 패킷 스니핑(패킷 도청)을 하고 있습니다.
> SSH 없이 Telnet 같은 평문 프로토콜을 쓰고 있다면 무엇이 노출될까요?

<details>
<summary>🔍 확인하기</summary>

평문 프로토콜에서 패킷 스니핑으로 볼 수 있는 것:

1. **비밀번호** — 로그인 시 입력하는 비밀번호가 그대로 전송
2. **입력하는 모든 명령어** — `rm -rf /important_data` 같은 것도
3. **명령어 출력 결과** — `/etc/passwd` 내용을 보려 했다면 그 내용도
4. **파일 내용** — `cat config.py`의 결과가 평문으로 전송

SSH는 이 모든 것을 **암호화**합니다. 패킷을 가로채도 무작위 바이트만 보입니다.

</details>

---

### SSH 동작의 핵심

---

> 🤔 **생각해보기**
>
> 아래는 SSH 연결 수립 과정의 단계입니다. 각 단계에서 무슨 일이 일어나는지 추론해보세요.
> (공개키/개인키 암호화 방식을 알고 있다면 더 잘 추론할 수 있습니다)
>
> 1. 서버가 공개키를 클라이언트에게 보낸다
> 2. 클라이언트가 무언가를 만들어 공개키로 암호화해서 보낸다
> 3. 서버가 개인키로 복호화한다
> 4. 이후 통신이 암호화된다
>
> 2번 단계에서 "무언가"가 무엇이고 왜 그것을 사용하는지 설명해보세요.

<details>
<summary>🔍 확인하기</summary>

**공개키/개인키 (비대칭 암호화) + 대칭 암호화의 결합:**

1. 서버가 **공개키**를 클라이언트에게 보냄 (공개된 자물쇠)
2. 클라이언트가 **랜덤 대칭 세션 키**를 생성하고, 서버의 공개키로 암호화해서 보냄
3. 서버가 자기만 가진 **개인키**로 복호화 → 세션 키 획득
4. 이후 모든 통신은 이 **세션 키(대칭 암호화)** 로 암호화

**왜 세션 키를 만드는가:**

비대칭 암호화(RSA)는 안전하지만 **느립니다**. 전체 통신을 비대칭으로 하면 느려집니다. 반면 대칭 암호화(AES)는 **빠릅니다**.

해결책: 비대칭으로 대칭 키를 **안전하게 교환**하고, 이후 통신은 빠른 대칭으로. 이것이 SSH(그리고 HTTPS)의 핸드쉐이크 원리입니다.

</details>

---

> 🤔 **생각해보기 — 포트 4242의 진짜 의미**
>
> 포트를 22 → 4242로 바꾸는 것이 "보안 강화"라고 할 수 있을까요?
> 아니면 단순한 노이즈 필터링인가요? 그 차이를 정확히 설명해보세요.

<details>
<summary>🔍 확인하기</summary>

**포트 변경 = 보안 강화가 아니라 소음 필터링입니다.**

인터넷에는 포트 22에 무차별 대입(brute force)을 시도하는 봇이 넘칩니다. 포트 22를 닫으면 이런 **자동화 공격의 소음**은 사라집니다. 서버 로그가 깔끔해집니다.

그러나:

```bash
nmap -p 1-65535 <IP>
```

이 명령 하나로 공격자는 4242에 SSH가 있다는 걸 몇 초 안에 알 수 있습니다.

**결론:** 포트 변경은 "보안 계층 중 하나"이지, 그것 자체로 안전하다고 할 수 없습니다. 진짜 보안은 강력한 비밀번호, SSH 키 인증, fail2ban, sudo 최소 권한 등의 레이어 조합입니다.

**root SSH 접속 차단의 이유:**

root로 직접 SSH가 가능하면, 공격자는 사용자명(`root`)을 이미 알고 있습니다. 비밀번호만 뚫으면 됩니다. 차단하면 공격자는 **유효한 사용자명**부터 알아내야 하므로 공격 난이도가 한 단계 높아집니다.

</details>

---

## 9. cron — 알람시계의 원리

### 개념

---

> 🤔 **생각해보기**
>
> 10분마다 서버 상태를 화면에 출력하는 스크립트가 있습니다.
> 다음 두 구현 방식의 문제점을 각각 지적해보세요:
>
> **방식 A:** `while true; do bash monitoring.sh | wall; sleep 600; done`
> **방식 B:** cron을 사용

<details>
<summary>🔍 확인하기</summary>

**방식 A (무한 루프)의 문제:**

1. **드리프트:** 스크립트 실행 시간이 15초라면, 실제 간격은 615초가 됩니다. 시간이 갈수록 오차가 누적됩니다.

2. **프로세스 죽으면 끝:** 서버 재부팅이나 프로세스 crash 시 자동으로 재시작하지 않습니다.

3. **시작 자동화 어려움:** 시스템 부팅 시 이 루프를 자동으로 시작하려면 추가 설정(`@reboot`)이 필요합니다.

**방식 B (cron)의 장점:**

- cron 데몬이 시스템 부팅 시 **자동 시작**
- 시스템 시계 기준으로 **정확한 시각**에 실행 (드리프트 없음)
- cron 데몬 자체는 systemd가 관리하므로 안정적
- crontab 파일만 수정하면 스크립트를 건드리지 않고 주기 변경 가능

</details>

---

### crontab 문법 — 직접 읽어보기

```
*/10 * * * * bash /etc/cron.d/monitoring.sh | wall
```

이 한 줄을 왼쪽부터 읽어봅시다:

```
┌─ */10 : 분 필드. */10은 "10으로 나누어 떨어지는 매 분" = 0, 10, 20, 30, 40, 50분
│  ┌─ * : 시 필드. *은 "매 시"
│  │  ┌─ * : 일 필드. "매일"
│  │  │  ┌─ * : 월 필드. "매월"
│  │  │  │  ┌─ * : 요일 필드. "매 요일"
│  │  │  │  │
*/10 * * * *  bash /etc/cron.d/monitoring.sh | wall
```

---

> 🤔 **생각해보기 — crontab 해석 퀴즈**
>
> 아래 세 표현식의 의미를 **클릭 전에 반드시** 정해보세요. 하나씩 클릭해서 확인하세요.

<details>
<summary>① `0 3 * * 1` 의 의미는?</summary>

**매주 월요일 오전 3시 정각**

- `0` = 0분 (정각)
- `3` = 3시
- `*` = 매일 (여기선 요일로 한정됨)
- `*` = 매월
- `1` = 월요일 (0=일, 1=월, ..., 6=토)

</details>

<details>
<summary>② `30 */2 * * *` 의 의미는?</summary>

**매 2시간마다 30분에 실행**

= 0시 30분, 2시 30분, 4시 30분, 6시 30분...

- `30` = 30분
- `*/2` = 2로 나누어지는 매 시 (0, 2, 4, 6, 8...)

</details>

<details>
<summary>③ `0 0 1 * *` 의 의미는?</summary>

**매월 1일 자정**

- `0` = 0분
- `0` = 0시 (자정)
- `1` = 1일
- `*` = 매월
- `*` = 요일 무관

</details>

---

> 🤔 **생각해보기**
>
> 평가자가 말합니다: "모니터링을 중단해라. 하지만 스크립트 파일을 **절대 건드리지 마라**."
> 어떤 방법이 있을까요? 핵심 원리는 "실행의 주체를 공격하는 것"입니다.

<details>
<summary>🔍 두 가지 방법 확인하기</summary>

**방법 1: crontab에서 해당 줄을 비활성화**

```bash
sudo crontab -u root -e
# 줄 앞에 # 추가하거나 삭제
```

스크립트 파일 자체는 그대로. 하지만 그것을 실행시키는 예약이 사라집니다.

**방법 2: cron 서비스 자체를 중지**

```bash
sudo systemctl stop cron
```

스크립트도 그대로, crontab도 그대로. 하지만 그것들을 실행하는 **cron 데몬**이 멈춥니다.

**원리:** 스크립트 = 악보. crontab = 공연 일정. cron 서비스 = 오케스트라 단원. 악보를 없애는 대신, 공연 일정을 취소하거나 단원 전체를 해산시킵니다.

</details>

---

> 🤔 **보너스 — `*/1`과 `1`의 차이**
>
> `*/1 * * * *` 과 `1 * * * *` 은 같은 건가요? 다르다면 어떻게 다른가요?

<details>
<summary>🔍 확인하기</summary>

**완전히 다릅니다.**

- `*/1 * * * *` = **매 1분마다** (0분, 1분, 2분, ... = `* * * * *`과 동일)
- `1 * * * *` = 매 시 **1분에만** (0:01, 1:01, 2:01, 3:01...)

`*/n`은 "n으로 나누어 떨어지는 모든 값"이고, 그냥 `n`은 "정확히 n인 경우"입니다.

실수하기 쉬운 차이입니다. 기억해두세요.

</details>

---

## 10. 비밀번호 정책 — 귀찮음의 이유

### 공격자의 관점에서 생각하기

---

> 🤔 **생각해보기**
>
> 당신이 공격자입니다. 서버의 SSH 포트(4242)를 찾았고, 사용자명도 알아냈습니다. 비밀번호만 뚫으면 됩니다.
> 어떤 순서로 비밀번호를 시도하겠습니까? **전략적 순서**를 정해보세요.

<details>
<summary>🔍 공격자의 실제 전략 확인하기</summary>

효율적인 공격자의 순서:

1. **사전 공격(Dictionary Attack):** `password`, `123456`, `admin`, `qwerty`, `iloveyou`... 가장 흔한 비밀번호 목록(rockyou.txt 등)을 먼저 시도. 수백만 계정 중 수십%가 이 목록에 있습니다.

2. **패턴 기반 추측:** 사용자명이 `kim42`라면 `Kim42!`, `kim42@`, `Kim2024!` 등.

3. **브루트포스(Brute Force):** 가능한 모든 조합. 4자리 숫자(`0000`~`9999`) = 10,000번. 8자리 소문자 = 약 2,000억 번.

**Born2beroot 정책이 막는 것:**

| 규칙 | 막는 공격 |
|------|---------|
| `minlen=10` | 브루트포스 (조합 수 기하급수적 증가) |
| `ucredit=-1 lcredit=-1 dcredit=-1` | 단순 조합 브루트포스 |
| `maxrepeat=3` | `aaaa`, `1111` 패턴 사전 공격 |
| `reject_username` | 사용자명 기반 추측 |
| `difok=7` | `Password1` → `Password2` 꼼수 |
| `PASS_MAX_DAYS 30` | 유출된 비밀번호의 장기 유효성 |
| `PASS_MIN_DAYS 2` | 연속 변경으로 이전 비밀번호 복귀하는 우회 |

</details>

---

> 🤔 **생각해보기 — `PASS_MIN_DAYS 2`의 역할**
>
> `PASS_MIN_DAYS 2`가 없다면, `difok=7` 정책을 어떻게 우회할 수 있을까요?
> 구체적인 우회 시나리오를 단계별로 설명해보세요.

<details>
<summary>🔍 확인하기</summary>

**우회 시나리오:**

1. 현재 비밀번호: `MyPass2024!`
2. → `XNewPass01!` (7자 이상 다름, OK)
3. → `YNewPass02!` (7자 이상 다름, OK)
4. → `ZNewPass03!` (7자 이상 다름, OK)
5. → ... (반복)
6. → `MyPass2024!` (결국 원래 비밀번호로 복귀!)

`difok=7`은 직전 비밀번호와 비교하므로, 중간에 다른 비밀번호를 여러 번 거치면 우회할 수 있습니다.

**`PASS_MIN_DAYS 2`가 있으면:** 각 비밀번호 변경 사이에 최소 2일을 기다려야 합니다. 실용적으로 원래 비밀번호로 돌아가는 것이 매우 번거로워집니다.

</details>

---

> 🤔 **생각해보기 — 이 정책의 대가**
>
> 이렇게 엄격한 정책의 **역효과**는 무엇일까요?
> 현실 세계에서 사용자들이 어떻게 반응하는지 예측해보세요.

<details>
<summary>🔍 확인하기 + 현대 보안의 관점</summary>

**역효과:**

- 사용자가 기억 못해 → **포스트잇에 적어 모니터에 붙임** (물리적 보안 최악)
- 30일마다 바꿔야 하니 → `Summer2024!` → `Autumn2024!` → **패턴**이 생김 (사전 공격에 취약)
- 복잡성 요구 → `P@ssw0rd!` 같은 **규칙 준수 패턴** (역시 사전 공격에 있음)

**현대 보안 기관의 관점:**

NIST(미국 국립표준기술연구소)는 2017년 이후 "**주기적 비밀번호 변경을 강제하지 말라**"고 권고를 바꿨습니다. 오히려 **길이가 긴 패스프레이즈**(`correct-horse-battery-staple` 같은)를 권장합니다.

Born2beroot은 현대 모범 사례를 가르치는 것이 아닙니다. **각 정책 요소가 어떤 공격 벡터를 방어하는지 이해**하게 하려는 교육 목적입니다. "왜 이 규칙이 있는가"를 설명할 수 있으면 됩니다.

</details>

---

# 2부: 손으로 증명하기

> 여기서부터는 실제 평가에서 시연하는 항목입니다.
> **각 명령어를 실행하기 전에**, 어떤 결과가 나올지 **입으로 소리 내어 예측**하세요.
> 예측이 맞았는지 확인하는 과정이 학습입니다.

---

## 11. 평가 전 점검

평가 시작 전 반드시:

- [ ] Git 저장소에 `signature.txt`와 `README.md`만 존재하는지
- [ ] VM에 **스냅샷이 없는 상태**인지 (v5.2 요구사항)
- [ ] `signature.txt`의 내용이 현재 `.vdi` 파일의 SHA-1 해시와 일치하는지
- [ ] 부팅 시 그래픽 환경 없이, 암호화 비밀번호를 요구하는지

---

## 12. 서명 검증

**호스트 터미널에서:**

```bash
cd ~/VirtualBox\ VMs/<VM이름>/
sha1sum <파일명>.vdi
```

---

> 🤔 **예측하기**
>
> 이 명령어는 무엇을 출력할까요?
> 왜 SHA-1인가요? MD5가 아니라?

<details>
<summary>🔍 확인하기</summary>

**출력:** 40자리 16진수 해시 + 파일명

```
a3f7c8d2e1b4f9c0... 파일명.vdi
```

이 값이 `signature.txt`와 **글자 하나까지** 동일해야 합니다.

**왜 SHA-1인가:**

42 School이 SHA-1을 지정했기 때문입니다. 기술적으로 SHA-1은 충돌 취약점이 발견되어 암호화 용도로는 더 이상 권장되지 않습니다(SHA-256/SHA-3 권장). 그러나 파일 **무결성 검증** 용도(파일이 바뀌지 않았는가)로는 여전히 실용적입니다. 평가자는 여러분의 VM 파일이 수정되지 않았음을 확인하려는 것입니다.

</details>

---

## 13. 서비스 상태 확인

```bash
sudo ufw status
sudo systemctl status ssh
sudo aa-status
```

---

> 🤔 **예측하기 — 클릭 전에 각 명령의 출력을 머릿속으로 그려보세요**

<details>
<summary>🔍 정상 출력 확인하기</summary>

**`sudo ufw status`:**
```
Status: active

To                         Action      From
--                         ------      ----
4242                       ALLOW       Anywhere
4242 (v6)                  ALLOW       Anywhere (v6)
```

**`sudo systemctl status ssh`:**
```
● ssh.service - OpenBSD Secure Shell server
   Active: active (running) since ...
```
`active (running)` 상태여야 합니다. 포트가 4242인지 `Port 4242`로 `/etc/ssh/sshd_config`에 설정되어 있어야 합니다.

**`sudo aa-status`:**
```
apparmor module is loaded.
XX profiles are loaded.
XX profiles are in enforce mode.
...
```
enforce 모드 프로파일이 있어야 합니다.

</details>

---

## 14. 사용자와 그룹

### 기존 확인

```bash
getent group sudo
getent group user42
```

---

> 🤔 **예측하기**
>
> 출력에 본인 로그인이 보여야 합니다.
> `getent group`과 `/etc/group`을 직접 읽는 것의 차이는 무엇인가요?

<details>
<summary>🔍 확인하기</summary>

`getent`는 **NSS(Name Service Switch)** 를 통해 조회합니다. 로컬 파일(`/etc/group`)뿐 아니라 LDAP, NIS, Active Directory 등 외부 디렉터리 서비스도 포함합니다.

로컬 환경에서는 결과가 같지만, 기업 환경에서 LDAP으로 사용자를 관리한다면 `/etc/group`에는 없어도 `getent`로는 보이는 그룹이 있을 수 있습니다.

**원리:** NSS는 어디서 정보를 가져올지 결정하는 계층입니다. `/etc/nsswitch.conf`에 설정됩니다.

</details>

---

### 새 사용자 생성

```bash
sudo adduser <evaluator_name>
```

---

> 🤔 **관찰하기**
>
> 비밀번호 설정 시 다음 각 경우를 시도해보세요. 무슨 메시지가 나오나요?
> - 8자 미만
> - 숫자 없는 것
> - 사용자명 포함한 것
> - 정책을 모두 만족하는 것

<details>
<summary>🔍 예상 메시지 확인하기</summary>

pam_pwquality 모듈이 활성화되어 있으면:

- 너무 짧음: `BAD PASSWORD: The password is shorter than 10 characters`
- 숫자 없음: `BAD PASSWORD: The password must contain at least 1 digit(s)`
- 사용자명 포함: `BAD PASSWORD: The password contains the user name in some form`
- 이전 비밀번호와 유사: `BAD PASSWORD: The password is too similar to the old one`

root로 실행 시 `enforce_for_root` 설정이 있어야 root의 비밀번호도 정책 적용을 받습니다.

</details>

---

```bash
sudo groupadd evaluating
sudo usermod -aG evaluating <evaluator_name>
getent group evaluating
```

---

> 🤔 **생각해보기 — 매우 중요한 함정**
>
> `usermod -aG` 에서 `-a` 를 빼고 `-G`만 쓰면 어떻게 되나요?
> 왜 이것이 "매우 위험"한가요?

<details>
<summary>🔍 확인하기 (절대 잊지 마세요)</summary>

**`-a` 없이 `-G`만 쓰면:**

현재 사용자가 속한 **모든 보조 그룹이 삭제**되고, `-G` 뒤에 지정한 그룹으로 **완전히 교체**됩니다.

예시:
```bash
# 현재 jsmith의 그룹: sudo, user42, docker
sudo usermod -G evaluating jsmith
# 이후 jsmith의 그룹: evaluating (나머지 전부 삭제!)
```

`sudo` 그룹에서 빠지면 `sudo` 명령을 쓸 수 없게 됩니다. root 비밀번호도 모른다면 사실상 관리자 권한을 잃게 됩니다.

**항상 `usermod -aG` 로 기억하세요. `-a`는 "append(추가)".**

</details>

---

## 15. 비밀번호 정책 시연

```bash
sudo chage -l <your_login>
```

---

> 🤔 **예측하기**
>
> Maximum, Minimum, Warning 값이 각각 얼마여야 하나요?
> 답을 먼저 말하고 실행해서 확인하세요.

<details>
<summary>🔍 예상 값 확인하기</summary>

Born2beroot v5.2 요구사항:

```
Maximum number of days between password change: 30
Minimum number of days between password change: 2
Number of days of warning before password expires: 7
```

이 값들이 다르다면 `/etc/login.defs`에서:
```
PASS_MAX_DAYS   30
PASS_MIN_DAYS   2
PASS_WARN_AGE   7
```

기존 사용자에게 소급 적용하려면 `chage -M 30 -m 2 -W 7 <username>`으로 수동 설정이 필요합니다.

</details>

---

```bash
cat /etc/pam.d/common-password | grep pam_pwquality
```

---

> 🤔 **도전 — 평가자 앞 실전**
>
> `minlen=10 difok=7 maxrepeat=3 dcredit=-1 ucredit=-1 lcredit=-1 reject_username enforce_for_root`
>
> 이 옵션들을 보지 않고, 각각이 어떤 공격 벡터를 방어하는지 설명할 수 있나요?
> 10번 섹션을 다시 읽지 않고 할 수 있다면 이해한 것입니다.

<details>
<summary>🔍 각 옵션 대응표 확인하기</summary>

| 옵션 | 방어 대상 |
|------|----------|
| `minlen=10` | 브루트포스 (조합 수 증가) |
| `difok=7` | 이전 비밀번호와 유사한 변경 |
| `maxrepeat=3` | `aaaa`, `1111` 패턴 |
| `dcredit=-1` | 숫자 없는 단순 비밀번호 |
| `ucredit=-1` | 대문자 없는 단순 비밀번호 |
| `lcredit=-1` | 소문자 없는 단순 비밀번호 |
| `reject_username` | 사용자명 기반 추측 공격 |
| `enforce_for_root` | root 계정도 정책 예외 없음 |

</details>

---

## 16. 호스트명 변경

```bash
hostnamectl
```

```bash
sudo hostnamectl set-hostname <new_hostname>
sudo nano /etc/hosts    # 127.0.1.1 줄의 호스트명도 변경
sudo reboot
```

---

> 🤔 **생각해보기**
>
> `/etc/hosts` 파일을 수정하지 않으면 어떻게 될까요?
> 시스템이 부팅되지 않을까요, 아니면 다른 종류의 문제가 생길까요?

<details>
<summary>🔍 확인하기</summary>

시스템은 정상 부팅됩니다. 그러나:

- `sudo` 명령 실행 시 매번 `sudo: unable to resolve host <new_hostname>: Name or service not known` 경고 출력
- 일부 서비스가 자신의 호스트명을 해석하지 못해 오작동

**이유:** `/etc/hosts`는 DNS 조회 전에 참조하는 로컬 이름 해석 파일입니다. 새 호스트명이 이 파일에 없으면 시스템이 자기 이름을 DNS에 물어보지만 응답이 없어 해석 실패가 발생합니다.

```
127.0.1.1    <new_hostname>    # 이 줄을 추가/수정해야 합니다
```

</details>

---

## 17. 파티션 확인

```bash
lsblk
```

---

> 🤔 **도전 — 출력의 모든 줄을 설명하세요**
>
> `lsblk` 출력을 보고, 평가자에게 각 줄을 설명하세요.
> 5번 섹션의 즉문즉답 카드를 다시 도전해보세요.

<details>
<summary>🔍 모범 설명 흐름</summary>

```
NAME                    TYPE  MOUNTPOINT
sda                     disk              ← 물리 디스크 전체 (예: 30GB VDI)
├─sda1                  part  /boot       ← 부팅 파티션 (암호화 밖)
├─sda2                  part              ← LUKS 암호화 컨테이너
│ └─sda2_crypt          crypt             ← 패스프레이즈로 열린 LUKS 장치
│   └─<VGName>-root     lvm   /           ← LV: 루트
│   └─<VGName>-home     lvm   /home       ← LV: 홈
│   └─<VGName>-var      lvm   /var        ← LV: 로그/캐시
│   └─<VGName>-swap     lvm   [SWAP]      ← LV: 스왑
│   └─...               lvm   ...
```

**설명 포인트:**
- `sda1`이 `/boot`인 이유: 부팅 시 LUKS가 아직 열리지 않았으므로, 커널과 부트로더는 암호화 밖에 있어야 합니다.
- `crypt` 장치: LUKS를 열면 나타나는 논리 장치. 이 안에 LVM이 있습니다.
- `lvm` 타입: LVM의 논리 볼륨. 파티션 테이블이 아닌 LVM 메타데이터로 관리됩니다.

</details>

---

## 18. sudo 검증

```bash
dpkg -l | grep sudo    # 설치 확인
```

```bash
ls /var/log/sudo/
cat /var/log/sudo/sudo.log
```

---

> 🤔 **실험**
>
> `sudo ls /root`를 실행한 뒤, 로그 파일을 다시 확인하세요.
> 새 항목이 추가되었나요? 로그에 기록된 정보에는 무엇이 포함되어 있나요?

<details>
<summary>🔍 로그 항목 설명</summary>

sudo.log에 기록되는 정보:

```
May 10 14:23:45 : kim42 : TTY=pts/0 ; PWD=/home/kim42 ; USER=root ; COMMAND=/bin/ls /root
```

- **타임스탬프:** 언제
- **사용자:** 누가 (`kim42`)
- **TTY:** 어떤 터미널에서
- **PWD:** 어떤 디렉터리에서
- **USER:** 어떤 권한으로 (`root`)
- **COMMAND:** 어떤 명령을 (`/bin/ls /root`)

`log_input`/`log_output`이 설정되어 있으면 추가로 입력과 출력도 별도 파일에 저장됩니다.

**이것이 보안 감사(audit)의 핵심입니다.** 보안 사고 시 "누가 언제 무엇을 했는지"를 추적할 수 있습니다.

</details>

---

## 19. UFW 조작

```bash
sudo ufw status numbered    # 현재 규칙
```

---

> 🤔 **예측하기**
>
> 포트 4242에 대한 규칙은 몇 개가 보일까요? 왜 2개일 수 있는지 설명해보세요.

<details>
<summary>🔍 확인하기</summary>

**2개가 보일 수 있습니다:** IPv4와 IPv6 각각.

```
     To                         Action      From
--   --                         ------      ----
[ 1] 4242                       ALLOW IN    Anywhere
[ 2] 4242 (v6)                  ALLOW IN    Anywhere (v6)
```

현대 시스템은 IPv4(`0.0.0.0`)와 IPv6(`::`)를 모두 지원하므로, UFW는 양쪽 모두에 규칙을 적용합니다.

</details>

---

```bash
sudo ufw allow 8080          # 추가
sudo ufw status numbered     # 확인
sudo ufw delete <번호>       # 삭제 (IPv4 먼저)
sudo ufw status numbered     # 번호 재확인 (중요!)
sudo ufw delete <번호>       # 삭제 (IPv6 — 번호가 밀렸음)
sudo ufw status numbered     # 원복 확인
```

---

> ⚠️ **함정 주의**
>
> 첫 번째 규칙을 삭제하면 나머지 번호가 **재배치**됩니다.
> 삭제할 때마다 `status numbered`로 번호를 **반드시 다시 확인**하세요.
> 자동화 스크립트에서 번호로 삭제하는 것이 위험한 이유이기도 합니다.

---

## 20. SSH 검증

```bash
dpkg -l | grep ssh    # 설치 확인
```

**호스트 터미널에서:**

```bash
ssh <your_login>@127.0.0.1 -p 4242
```

```bash
ssh root@127.0.0.1 -p 4242
```

---

> 🤔 **예측하기**
>
> 두 번째 명령(`ssh root@...`)의 결과를 예측하세요.
> 왜 그 결과가 나와야 하는지 8번 섹션의 논리로 설명해보세요.

<details>
<summary>🔍 확인하기</summary>

**`Permission denied (publickey,password)`** 가 나와야 합니다.

이유: `/etc/ssh/sshd_config`에 `PermitRootLogin no`가 설정되어 있어야 합니다. 이 설정이 없으면 실격입니다.

**왜 root SSH를 막는가:**

공격자가 사용자명(`root`)을 이미 알고 있으면, 비밀번호 브루트포스만 시도하면 됩니다. 막으면 공격자는 유효한 사용자명부터 알아내야 하므로 공격 진입장벽이 높아집니다.

</details>

---

## 21. 모니터링 스크립트

```bash
cat /etc/cron.d/monitoring.sh
# (또는 본인이 저장한 경로)
```

---

> 🤔 **도전 — 스크립트 완전 해부**
>
> 아래 표의 각 명령어를 직접 터미널에서 실행해보고, 스크립트의 출력과 어떻게 연결되는지 확인하세요.
> 이 작업을 완료하면 평가자가 스크립트 어느 줄을 짚어도 설명할 수 있습니다.

| 스크립트 내 명령어 | 직접 실행 | 대응되는 모니터링 항목 |
|---|---|---|
| `uname -a` | 터미널에서 실행 | Architecture (OS 커널 버전) |
| `lscpu \| grep Socket` | 터미널에서 실행 | Physical CPU 수 |
| `nproc` | 터미널에서 실행 | Virtual CPU 수 |
| `free -m` | 터미널에서 실행 | RAM 사용량 |
| `df -h` | 터미널에서 실행 | 디스크 사용량 |
| `top -bn1 \| grep 'Cpu'` | 터미널에서 실행 | CPU 사용률 |
| `who -b` | 터미널에서 실행 | 마지막 부팅 시각 |
| `lsblk \| grep -c 'LVM'` | 터미널에서 실행 | LVM 사용 여부 |
| `ss -t state established` | 터미널에서 실행 | 현재 TCP 연결 수 |
| `who` | 터미널에서 실행 | 로그인한 사용자 수 |
| `ip a` | 터미널에서 실행 | 네트워크 인터페이스와 IP |
| `ip link show \| grep 'ether'` | 터미널에서 실행 | MAC 주소 |
| `journalctl _COMM=sudo \| grep COMMAND` | 터미널에서 실행 | sudo 사용 횟수 |

<details>
<summary>🔍 각 명령어 해설이 필요하면 클릭</summary>

- `uname -a`: 커널 이름, 버전, 아키텍처 등 전체 정보
- `lscpu | grep Socket`: 물리 CPU 소켓 수 (하이퍼스레딩 전 실제 코어 수)
- `nproc`: OS가 인식하는 논리 CPU 수 (하이퍼스레딩 포함)
- `free -m`: MB 단위 메모리. `used`, `free`, `available` 구분 주의
- `df -h`: 파일시스템별 디스크 사용량. `-h`는 human-readable
- `who -b`: 시스템 부팅 시각 (`b`=boot)
- `ss -t state established`: 현재 ESTABLISHED 상태 TCP 연결
- `journalctl _COMM=sudo | grep COMMAND | wc -l`: sudo 명령 실행 횟수 카운팅

</details>

---

## 22. cron 주기 변경

```bash
sudo crontab -u root -e
```

`*/10`을 `*/1`로 변경하고 저장합니다.

---

> 🤔 **관찰하기**
>
> 변경 후 약 1분 기다리세요. 어디서 메시지가 표시되나요?
> `wall` 명령어의 역할을 설명해보세요.

<details>
<summary>🔍 확인하기</summary>

`wall` (write all) 명령어는 현재 로그인한 **모든 사용자의 모든 터미널**에 메시지를 브로드캐스트합니다. 열려 있는 SSH 세션 전부에서 메시지가 보여야 합니다.

**복원 순서:**
1. `sudo crontab -u root -e`
2. `*/1` → `*/10` 으로 복원
3. 저장

또는 cron을 완전히 중지하려면:
```bash
sudo systemctl stop cron
```

</details>

---

> 🤔 **마지막 확인 — `*/1` vs `1`**
>
> 이 둘은 같은가요? 다르다면 어떻게 다른지 지금 바로 답해보세요.
> (9번 섹션에서 이미 다뤘습니다. 기억하고 있나요?)

<details>
<summary>🔍 확인하기</summary>

**완전히 다릅니다.**

- `*/1 * * * *` = 매 1분마다 = `* * * * *` 과 동일
- `1 * * * *` = 매 시 1분에만 (01:01, 02:01, 03:01...)

</details>

---

# 마무리 — 최종 자기 진단

이 문서를 한 번 제대로 겪었다면, 평가자의 질문에 외운 답을 낭송하는 것이 아니라 **자기 언어로 설명**할 수 있어야 합니다.

---

> 📋 **최종 구술 시험 — 이 문서를 닫고 입으로 답하세요**
>
> 막히는 질문의 번호를 기억해두었다가, 해당 섹션으로 돌아가서 **생각해보기 구간**을 다시 겪으세요.

<details>
<summary>① 가상 머신이 뭐야? 왜 쓰는 거야?</summary>

**핵심:** 소프트웨어가 하드웨어인 척 / 하이퍼바이저 / 격리 / 스냅샷 / 듀얼부팅과의 차이(동시 실행)

</details>

<details>
<summary>② Debian을 왜 골랐어?</summary>

**핵심:** 초보자 진입장벽 낮음 / APT 생태계 / AppArmor·UFW가 SELinux·firewalld보다 직관적 / 커뮤니티 문서 방대 / Ubuntu의 기반

</details>

<details>
<summary>③ apt와 aptitude가 다른 게 뭐야?</summary>

**핵심:** 의존성 충돌 시 apt는 멈춤, aptitude는 해결책 제시 / apt가 스크립트에 적합 / aptitude는 텍스트 UI 제공

</details>

<details>
<summary>④ AppArmor가 뭐하는 건지 한 문장으로</summary>

**핵심:** "각 프로그램에 프로파일로 허용된 파일·네트워크 접근만 허가하여, 프로그램이 침해당해도 피해 범위를 프로파일 안으로 제한한다."

</details>

<details>
<summary>⑤ 파티션은 왜 나눠? LVM은 거기에 뭘 더해줘?</summary>

**파티션:** 한 영역 문제가 다른 영역에 영향을 주지 않도록 / 로그 폭주로 OS 마비 방지
**LVM:** 시스템 가동 중에 볼륨 크기 동적 변경 가능 / 여러 디스크 통합 가능

</details>

<details>
<summary>⑥ root로 직접 로그인하면 안 되는 이유?</summary>

**핵심:** 실수 시 무제한 영향 / 탈취 시 게임 오버 / 개인별 추적 불가 / 최소 권한 원칙

</details>

<details>
<summary>⑦ 방화벽은 뭘 하는 거고, 포트가 뭐야?</summary>

**포트:** IP = 건물 주소, 포트 = 호실 번호 (65535개)
**방화벽:** 쓰지 않는 모든 문을 잠그고, 필요한 문만 열어두는 것

</details>

<details>
<summary>⑧ SSH가 왜 필요해? 포트를 22에서 바꾸는 게 진짜 보안이야?</summary>

**SSH 필요성:** 원격 접속 + 모든 통신 암호화 (비밀번호 포함)
**포트 변경:** 보안이 아니라 소음 필터링. 자동화 봇 회피용. 포트 스캔으로 금방 발견됨.

</details>

<details>
<summary>⑨ cron이 뭐야? 스크립트 안 건드리고 어떻게 멈춰?</summary>

**cron:** 정해진 시각에 명령을 자동 실행하는 데몬
**중단 방법:** crontab에서 줄 주석 처리 (`#`) / 또는 `systemctl stop cron`

</details>

<details>
<summary>⑩ 비밀번호를 10자 이상으로 하는 게 왜 중요해? PASS_MIN_DAYS는 왜 있어?</summary>

**10자 이상:** 조합 수 기하급수적 증가 → 브루트포스 현실적 불가능
**PASS_MIN_DAYS:** difok=7을 연속 변경으로 우회하는 것 방지 (최소 2일 간격 강제)

</details>

---

모든 항목에 막힘 없이 답했다면 — 이미 당신은 이것을 **이해**한 겁니다.

평가자의 질문은 이 목록 안에 있습니다. 겁낼 것이 없습니다.
